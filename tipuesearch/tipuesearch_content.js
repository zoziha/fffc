var tipuesearch = {"pages":[{"title":" Fortran free function collection ","text":"Fortran free function collection FFFC 这主要是我个人编程用到的 通用 的函数集合，包括一些常用的数学函数、字符串操作、文件系统操作、随机数生成、统计函数、线性代数等等。 除此之外，我还编制了用于船海专业的函数库，它对其它领域的人可能没有什么帮助，没有包含在这里。\n并且，我还常常使用一些函数库，它们可以作为本库在数值算法上的补充： FFTW ：快速傅里叶变换 LAPACK ：线性代数 OpenBLAS ：线性代数 minpack ：最小二乘法 argparse-f ：命令行参数解析 hdf5 ：高性能数据格式 toml-f ：TOML格式文件解析 json-fortran ：JSON格式文件解析 fhash ：哈希表 fortran-lua ：Lua脚本解析 别忘了，Fortran语言的内置函数库也是很强大的，配置文件也可以采用Namelist格式，也可以借助接口使用C库。 一些有用的Fortran编程工具： fpm ：Fortran包管理器 meson ：构建系统 cmake ：构建系统 gfortran ：Fortran编译器 ifort ：Fortran编译器 vtune ：性能分析工具 gprof ：性能分析工具 valgrind ：内存泄漏检测工具 gdb ：调试工具 doxygen ：文档生成工具 ford ：文档生成工具 fprettify ：Fortran代码格式化工具 vscode ：编辑器 notepad3 ：编辑器 vim ：编辑器 emacs ：编辑器 git ：版本控制工具 github ：代码托管平台 gitee ：代码托管平台 fortls ：Fortran语言服务器 msys2 ：Windows下的Linux环境 cygwin ：Windows下的Linux环境 wsl ：Windows下的Linux环境 vscode-fortran-support ：VSCode插件 fortran-discourse ：Fortran讨论组 fortran网站 ：Fortran网站 octave ：Matlab的开源替代品 powershell ：Windows下的脚本语言 starship ：命令行提示符 fish ：命令行提示符 visual-studio ：IDE codeblocks ：IDE lfortran ：Fortran编译器 j3-fortran ：Fortran标准化组织 flang ：Fortran编译器 nvfortran ：Fortran编译器 Developer Info 左志华 哈尔滨工程大学-船舶与海洋结构物设计制造","tags":"home","loc":"index.html"},{"title":"timer – Fortran free function collection ","text":"type, public :: timer Contents Type-Bound Procedures nowtime toc tic Source Code timer Type-Bound Procedures procedure, public,  :: nowtime public  function nowtime (self) result(t) Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: self Return Value character(len=23) procedure, public,  :: toc public  function toc (self) Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: self Return Value real(kind=fffc_real_kind) procedure, public,  :: tic public  subroutine tic (self) Arguments Type Intent Optional Attributes Name class( timer ), intent(out) :: self Source Code type timer integer , private :: seed contains procedure :: tic , toc , nowtime end type timer","tags":"","loc":"type/timer.html"},{"title":"terminal – Fortran free function collection ","text":"type, public :: terminal Contents Type-Bound Procedures setup progress_bar info warning error success red yellow green blue Source Code terminal Type-Bound Procedures procedure, public,  :: setup => set_terminal private  subroutine set_terminal(self) 设置终端输出 Arguments Type Intent Optional Attributes Name class( terminal ), intent(out) :: self procedure, public,  :: progress_bar => terminal_progress_bar private  subroutine terminal_progress_bar(self, msg, p) 进度条 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg real, intent(in) :: p procedure, public,  :: info => terminal_info private  subroutine terminal_info(self, msg) 信息 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg procedure, public,  :: warning => terminal_warning private  subroutine terminal_warning(self, msg) 警告 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg procedure, public,  :: error => terminal_error private  subroutine terminal_error(self, msg) 错误 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg procedure, public,  :: success => terminal_success private  subroutine terminal_success(self, msg) 成功 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg procedure, public,  :: red private pure function red(self, msg) 红色 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg Return Value character(len=:), allocatable procedure, public,  :: yellow private pure function yellow(self, msg) 黄色 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg Return Value character(len=:), allocatable procedure, public,  :: green private pure function green(self, msg) 绿色 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg Return Value character(len=:), allocatable procedure, public,  :: blue private pure function blue(self, msg) 蓝色 Arguments Type Intent Optional Attributes Name class( terminal ), intent(in) :: self character(len=*), intent(in) :: msg Return Value character(len=:), allocatable Source Code type terminal logical , private :: use_color = . false . contains procedure :: setup => set_terminal procedure :: progress_bar => terminal_progress_bar procedure :: info => terminal_info procedure :: warning => terminal_warning procedure :: error => terminal_error procedure :: success => terminal_success procedure :: blue , green , yellow , red end type terminal","tags":"","loc":"type/terminal.html"},{"title":"random_normal – Fortran free function collection","text":"public  function random_normal() result(fn_val) Arguments None Return Value real Contents Source Code random_normal Source Code FUNCTION random_normal () RESULT ( fn_val ) ! Adapted from the following Fortran 77 code !      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM. !      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE, !      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435. !  The function random_normal() returns a normally distributed pseudo-random !  number with zero mean and unit variance. !  The algorithm uses the ratio of uniforms method of A.J. Kinderman !  and J.F. Monahan augmented with quadratic bounding curves. REAL :: fn_val !     Local variables REAL :: s = 0.449871 , t = - 0.386595 , a = 0.19600 , b = 0.25472 , & r1 = 0.27597 , r2 = 0.27846 , u , v , x , y , q !     Generate P = (u,v) uniform in rectangle enclosing acceptance region DO CALL RANDOM_NUMBER ( u ) CALL RANDOM_NUMBER ( v ) v = 1.7156 * ( v - half ) !     Evaluate the quadratic form x = u - s y = ABS ( v ) - t q = x ** 2 + y * ( a * y - b * x ) !     Accept P if inside inner ellipse IF ( q < r1 ) EXIT !     Reject P if outside outer ellipse IF ( q > r2 ) CYCLE !     Reject P if outside acceptance region IF ( v ** 2 < - 4.0 * LOG ( u ) * u ** 2 ) EXIT END DO !     Return ratio of P's coordinates as the normal deviate fn_val = v / u RETURN END FUNCTION random_normal","tags":"","loc":"proc/random_normal.html"},{"title":"random_gamma – Fortran free function collection","text":"public  function random_gamma(s, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: s logical, intent(in) :: first Return Value real Contents Source Code random_gamma Source Code FUNCTION random_gamma ( s , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 !     FUNCTION GENERATES A RANDOM GAMMA VARIATE. !     CALLS EITHER random_gamma1 (S > 1.0) !     OR random_exponential (S = 1.0) !     OR random_gamma2 (S < 1.0). !     S = SHAPE PARAMETER OF DISTRIBUTION (0 < REAL). REAL , INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first REAL :: fn_val IF ( s <= zero ) THEN WRITE ( * , * ) 'SHAPE PARAMETER VALUE MUST BE POSITIVE' STOP END IF IF ( s > one ) THEN fn_val = random_gamma1 ( s , first ) ELSE IF ( s < one ) THEN fn_val = random_gamma2 ( s , first ) ELSE fn_val = random_exponential () END IF RETURN END FUNCTION random_gamma","tags":"","loc":"proc/random_gamma.html"},{"title":"random_gamma1 – Fortran free function collection","text":"public  function random_gamma1(s, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: s logical, intent(in) :: first Return Value real Contents Source Code random_gamma1 Source Code FUNCTION random_gamma1 ( s , first ) RESULT ( fn_val ) ! Uses the algorithm in ! Marsaglia, G. and Tsang, W.W. (2000) `A simple method for generating ! gamma variables', Trans. om Math. Software (TOMS), vol.26(3), pp.363-372. ! Generates a random gamma deviate for shape parameter s >= 1. REAL , INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first REAL :: fn_val ! Local variables REAL , SAVE :: c , d REAL :: u , v , x IF ( first ) THEN d = s - one / 3. c = one / SQRT ( 9.0 * d ) END IF ! Start of main loop DO ! Generate v = (1+cx)&#94;3 where x is random normal; repeat if v <= 0. DO x = random_normal () v = ( one + c * x ) ** 3 IF ( v > zero ) EXIT END DO ! Generate uniform variable U CALL RANDOM_NUMBER ( u ) IF ( u < one - 0.0331 * x ** 4 ) THEN fn_val = d * v EXIT ELSE IF ( LOG ( u ) < half * x ** 2 + d * ( one - v + LOG ( v ))) THEN fn_val = d * v EXIT END IF END DO RETURN END FUNCTION random_gamma1","tags":"","loc":"proc/random_gamma1.html"},{"title":"random_gamma2 – Fortran free function collection","text":"public  function random_gamma2(s, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: s logical, intent(in) :: first Return Value real Contents Source Code random_gamma2 Source Code FUNCTION random_gamma2 ( s , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM ! A GAMMA DISTRIBUTION WITH DENSITY PROPORTIONAL TO ! GAMMA2**(S-1) * EXP(-GAMMA2), ! USING A SWITCHING METHOD. !    S = SHAPE PARAMETER OF DISTRIBUTION !          (REAL < 1.0) REAL , INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables REAL :: r , x , w REAL , SAVE :: a , p , c , uf , vr , d IF ( s <= zero . OR . s >= one ) THEN WRITE ( * , * ) 'SHAPE PARAMETER VALUE OUTSIDE PERMITTED RANGE' STOP END IF IF ( first ) THEN ! Initialization, if necessary a = one - s p = a / ( a + s * EXP ( - a )) IF ( s < vsmall ) THEN WRITE ( * , * ) 'SHAPE PARAMETER VALUE TOO SMALL' STOP END IF c = one / s uf = p * ( vsmall / a ) ** s vr = one - vsmall d = a * LOG ( a ) END IF DO CALL RANDOM_NUMBER ( r ) IF ( r >= vr ) THEN CYCLE ELSE IF ( r > p ) THEN x = a - LOG (( one - r ) / ( one - p )) w = a * LOG ( x ) - d ELSE IF ( r > uf ) THEN x = a * ( r / p ) ** c w = x ELSE fn_val = zero RETURN END IF CALL RANDOM_NUMBER ( r ) IF ( one - r <= w . AND . r > zero ) THEN IF ( r * ( w + one ) >= one ) CYCLE IF ( - LOG ( r ) <= w ) CYCLE END IF EXIT END DO fn_val = x RETURN END FUNCTION random_gamma2","tags":"","loc":"proc/random_gamma2.html"},{"title":"random_chisq – Fortran free function collection","text":"public  function random_chisq(ndf, first) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndf logical, intent(in) :: first Return Value real Contents Source Code random_chisq Source Code FUNCTION random_chisq ( ndf , first ) RESULT ( fn_val ) !     Generates a random variate from the chi-squared distribution with !     ndf degrees of freedom INTEGER , INTENT ( IN ) :: ndf LOGICAL , INTENT ( IN ) :: first REAL :: fn_val fn_val = two * random_gamma ( half * ndf , first ) RETURN END FUNCTION random_chisq","tags":"","loc":"proc/random_chisq.html"},{"title":"random_exponential – Fortran free function collection","text":"public  function random_exponential() result(fn_val) Arguments None Return Value real Contents Source Code random_exponential Source Code FUNCTION random_exponential () RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM ! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL ! TO EXP(-random_exponential), USING INVERSION. REAL :: fn_val !     Local variable REAL :: r DO CALL RANDOM_NUMBER ( r ) IF ( r > zero ) EXIT END DO fn_val = - LOG ( r ) RETURN END FUNCTION random_exponential","tags":"","loc":"proc/random_exponential.html"},{"title":"random_Weibull – Fortran free function collection","text":"public  function random_Weibull(a) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: a Return Value real Contents Source Code random_Weibull Source Code FUNCTION random_Weibull ( a ) RESULT ( fn_val ) !     Generates a random variate from the Weibull distribution with !     probability density: !                      a !               a-1  -x !     f(x) = a.x    e REAL , INTENT ( IN ) :: a REAL :: fn_val !     For speed, there is no checking that a is not zero or very small. fn_val = random_exponential () ** ( one / a ) RETURN END FUNCTION random_Weibull","tags":"","loc":"proc/random_weibull.html"},{"title":"random_beta – Fortran free function collection","text":"public  function random_beta(aa, bb, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: aa real, intent(in) :: bb logical, intent(in) :: first Return Value real Contents Source Code random_beta Source Code FUNCTION random_beta ( aa , bb , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,1] ! FROM A BETA DISTRIBUTION WITH DENSITY ! PROPORTIONAL TO BETA**(AA-1) * (1-BETA)**(BB-1). ! USING CHENG'S LOG LOGISTIC METHOD. !     AA = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) !     BB = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) REAL , INTENT ( IN ) :: aa , bb LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables REAL , PARAMETER :: aln4 = 1.3862944 REAL :: a , b , g , r , s , x , y , z REAL , SAVE :: d , f , h , t , c LOGICAL , SAVE :: swap IF ( aa <= zero . OR . bb <= zero ) THEN WRITE ( * , * ) 'IMPERMISSIBLE SHAPE PARAMETER VALUE(S)' STOP END IF IF ( first ) THEN ! Initialization, if necessary a = aa b = bb swap = b > a IF ( swap ) THEN g = b b = a a = g END IF d = a / b f = a + b IF ( b > one ) THEN h = SQRT (( two * a * b - f ) / ( f - two )) t = one ELSE h = b t = one / ( one + ( a / ( vlarge * b )) ** b ) END IF c = a + h END IF DO CALL RANDOM_NUMBER ( r ) CALL RANDOM_NUMBER ( x ) s = r * r * x IF ( r < vsmall . OR . s <= zero ) CYCLE IF ( r < t ) THEN x = LOG ( r / ( one - r )) / h y = d * EXP ( x ) z = c * x + f * LOG (( one + d ) / ( one + y )) - aln4 IF ( s - one > z ) THEN IF ( s - s * z > one ) CYCLE IF ( LOG ( s ) > z ) CYCLE END IF fn_val = y / ( one + y ) ELSE IF ( 4.0 * s > ( one + one / d ) ** f ) CYCLE fn_val = one END IF EXIT END DO IF ( swap ) fn_val = one - fn_val RETURN END FUNCTION random_beta","tags":"","loc":"proc/random_beta.html"},{"title":"random_t – Fortran free function collection","text":"public  function random_t(m) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Return Value real Contents Source Code random_t Source Code FUNCTION random_t ( m ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE FROM A ! T DISTRIBUTION USING KINDERMAN AND MONAHAN'S RATIO METHOD. !     M = DEGREES OF FREEDOM OF DISTRIBUTION !           (1 <= 1NTEGER) INTEGER , INTENT ( IN ) :: m REAL :: fn_val !     Local variables REAL , SAVE :: s , c , a , f , g REAL :: r , x , v REAL , PARAMETER :: three = 3.0 , four = 4.0 , quart = 0.25 , & five = 5.0 , sixteen = 1 6.0 INTEGER :: mm = 0 IF ( m < 1 ) THEN WRITE ( * , * ) 'IMPERMISSIBLE DEGREES OF FREEDOM' STOP END IF IF ( m /= mm ) THEN ! Initialization, if necessary s = m c = - quart * ( s + one ) a = four / ( one + one / s ) ** c f = sixteen / a IF ( m > 1 ) THEN g = s - one g = (( s + one ) / g ) ** c * SQRT (( s + s ) / g ) ELSE g = one END IF mm = m END IF DO CALL RANDOM_NUMBER ( r ) IF ( r <= zero ) CYCLE CALL RANDOM_NUMBER ( v ) x = ( two * v - one ) * g / r v = x * x IF ( v > five - a * r ) THEN IF ( m >= 1 . AND . r * ( v + three ) > f ) CYCLE IF ( r > ( one + v / s ) ** c ) CYCLE END IF EXIT END DO fn_val = x RETURN END FUNCTION random_t","tags":"","loc":"proc/random_t.html"},{"title":"random_inv_gauss – Fortran free function collection","text":"public  function random_inv_gauss(h, b, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: h real, intent(in) :: b logical, intent(in) :: first Return Value real Contents Source Code random_inv_gauss Source Code FUNCTION random_inv_gauss ( h , b , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY] FROM ! A REPARAMETERISED GENERALISED INVERSE GAUSSIAN (GIG) DISTRIBUTION ! WITH DENSITY PROPORTIONAL TO  GIG**(H-1) * EXP(-0.5*B*(GIG+1/GIG)) ! USING A RATIO METHOD. !     H = PARAMETER OF DISTRIBUTION (0 <= REAL) !     B = PARAMETER OF DISTRIBUTION (0 < REAL) REAL , INTENT ( IN ) :: h , b LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables REAL :: ym , xm , r , w , r1 , r2 , x REAL , SAVE :: a , c , d , e REAL , PARAMETER :: quart = 0.25 IF ( h < zero . OR . b <= zero ) THEN WRITE ( * , * ) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' STOP END IF IF ( first ) THEN ! Initialization, if necessary IF ( h > quart * b * SQRT ( vlarge )) THEN WRITE ( * , * ) 'THE RATIO H:B IS TOO SMALL' STOP END IF e = b * b d = h + one ym = ( - d + SQRT ( d * d + e )) / b IF ( ym < vsmall ) THEN WRITE ( * , * ) 'THE VALUE OF B IS TOO SMALL' STOP END IF d = h - one xm = ( d + SQRT ( d * d + e )) / b d = half * d e = - quart * b r = xm + one / xm w = xm * ym a = w ** ( - half * h ) * SQRT ( xm / ym ) * EXP ( - e * ( r - ym - one / ym )) IF ( a < vsmall ) THEN WRITE ( * , * ) 'THE VALUE OF H IS TOO LARGE' STOP END IF c = - d * LOG ( xm ) - e * r END IF DO CALL RANDOM_NUMBER ( r1 ) IF ( r1 <= zero ) CYCLE CALL RANDOM_NUMBER ( r2 ) x = a * r2 / r1 IF ( x <= zero ) CYCLE IF ( LOG ( r1 ) < d * LOG ( x ) + e * ( x + one / x ) + c ) EXIT END DO fn_val = x RETURN END FUNCTION random_inv_gauss","tags":"","loc":"proc/random_inv_gauss.html"},{"title":"random_Poisson – Fortran free function collection","text":"public  function random_Poisson(mu, first) result(ival) Translated to Fortran 90 by Alan Miller from : RANLIB Library of Fortran Routines for Random Number Generation Compiled and Written by : Barry W . Brown James Lovato Department of Biomathematics , Box 237 The University of Texas , M . D . Anderson Cancer Center 1515 Holcombe Boulevard Houston , TX 77030 This work was supported by grant CA-16672 from the National Cancer Institute. Arguments Type Intent Optional Attributes Name real, intent(in) :: mu logical, intent(in) :: first Return Value integer Contents Source Code random_Poisson Source Code FUNCTION random_Poisson ( mu , first ) RESULT ( ival ) !********************************************************************** !     Translated to Fortran 90 by Alan Miller from: !                           RANLIB ! !     Library of Fortran Routines for Random Number Generation ! !                    Compiled and Written by: ! !                         Barry W. Brown !                          James Lovato ! !             Department of Biomathematics, Box 237 !             The University of Texas, M.D. Anderson Cancer Center !             1515 Holcombe Boulevard !             Houston, TX      77030 ! ! This work was supported by grant CA-16672 from the National Cancer Institute. !                    GENerate POIsson random deviate !                            Function ! Generates a single random deviate from a Poisson distribution with mean mu. !                            Arguments !     mu --> The mean of the Poisson distribution from which !            a random deviate is to be generated. !                              REAL mu !                              Method !     For details see: !               Ahrens, J.H. and Dieter, U. !               Computer Generation of Poisson Deviates !               From Modified Normal Distributions. !               ACM Trans. Math. Software, 8, 2 !               (June 1982),163-179 !     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT !     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL !     SEPARATION OF CASES A AND B !     .. Scalar Arguments .. REAL , INTENT ( IN ) :: mu LOGICAL , INTENT ( IN ) :: first INTEGER :: ival !     .. !     .. Local Scalars .. REAL :: b1 , b2 , c , c0 , c1 , c2 , c3 , del , difmuk , e , fk , fx , fy , g , & omega , px , py , t , u , v , x , xx REAL , SAVE :: s , d , p , q , p0 INTEGER :: j , k , kflag LOGICAL , SAVE :: full_init INTEGER , SAVE :: l , m !     .. !     .. Local Arrays .. REAL , SAVE :: pp ( 35 ) !     .. !     .. Data statements .. REAL , PARAMETER :: a0 = - . 5 , a1 = . 3333333 , a2 = - . 2500068 , a3 = . 2000118 , & a4 = - . 1661269 , a5 = . 1421878 , a6 = - . 1384794 , & a7 = . 1250060 REAL , PARAMETER :: fact ( 10 ) = ( / 1. , 1. , 2. , 6. , 2 4. , 12 0. , 72 0. , 504 0. , & 4032 0. , 36288 0. / ) !     .. !     .. Executable Statements .. IF ( mu > 1 0.0 ) THEN !     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED) IF ( first ) THEN s = SQRT ( mu ) d = 6.0 * mu * mu !             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL !             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484) !             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 . l = mu - 1.1484 full_init = . false . END IF !     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE g = mu + s * random_normal () IF ( g > 0.0 ) THEN ival = g !     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH IF ( ival >= l ) RETURN !     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U fk = ival difmuk = mu - fk CALL RANDOM_NUMBER ( u ) IF ( d * u >= difmuk * difmuk * difmuk ) RETURN END IF !     STEP P. PREPARATIONS FOR STEPS Q AND H. !             (RECALCULATIONS OF PARAMETERS IF NECESSARY) !             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7. !             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE !             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK. !             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION. IF (. NOT . full_init ) THEN omega = . 3989423 / s b1 = . 416666 7E-1 / mu b2 = . 3 * b1 * b1 c3 = . 1428571 * b1 * b2 c2 = b2 - 1 5. * c3 c1 = b1 - 6. * b2 + 4 5. * c3 c0 = 1. - b1 + 3. * b2 - 1 5. * c3 c = . 1069 / mu full_init = . true . END IF IF ( g < 0.0 ) GO TO 50 !             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN) kflag = 0 GO TO 70 !     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE) 40 IF ( fy - u * fy <= py * EXP ( px - fx )) RETURN !     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL !             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT' !             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.) 50 e = random_exponential () CALL RANDOM_NUMBER ( u ) u = u + u - one t = 1.8 + SIGN ( e , u ) IF ( t <= ( - . 6744 )) GO TO 50 ival = mu + s * t fk = ival difmuk = mu - fk !             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN) kflag = 1 GO TO 70 !     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION) 60 IF ( c * ABS ( u ) > py * EXP ( px + e ) - fy * EXP ( fx + e )) GO TO 50 RETURN !     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY. !             CASE ival < 10 USES FACTORIALS FROM TABLE FACT 70 IF ( ival >= 10 ) GO TO 80 px = - mu py = mu ** ival / fact ( ival + 1 ) GO TO 110 !             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION !             A0-A7 FOR ACCURACY WHEN ADVISABLE !             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5) 80 del = . 833333 3E-1 / fk del = del - 4.8 * del * del * del v = difmuk / fk IF ( ABS ( v ) > 0.25 ) THEN px = fk * LOG ( one + v ) - difmuk - del ELSE px = fk * v * v * ((((((( a7 * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v + a0 ) - del END IF py = . 3989423 / SQRT ( fk ) 110 x = ( half - difmuk ) / s xx = x * x fx = - half * xx fy = omega * ((( c3 * xx + c2 ) * xx + c1 ) * xx + c0 ) IF ( kflag <= 0 ) GO TO 40 GO TO 60 !--------------------------------------------------------------------------- !     C A S E  B.    mu < 10 !     START NEW TABLE AND CALCULATE P0 IF NECESSARY ELSE IF ( first ) THEN m = MAX ( 1 , INT ( mu )) l = 0 p = EXP ( - mu ) q = p p0 = p END IF !     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD DO CALL RANDOM_NUMBER ( u ) ival = 0 IF ( u <= p0 ) RETURN !     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE !             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES !             (0.458=PP(9) FOR MU=10) IF ( l == 0 ) GO TO 150 j = 1 IF ( u > 0.458 ) j = MIN ( l , m ) DO k = j , l IF ( u <= pp ( k )) GO TO 180 END DO IF ( l == 35 ) CYCLE !     STEP C. CREATION OF NEW POISSON PROBABILITIES P !             AND THEIR CUMULATIVES Q=PP(K) 150 l = l + 1 DO k = l , 35 p = p * mu / k q = q + p pp ( k ) = q IF ( u <= q ) GO TO 170 END DO l = 35 END DO 170 l = k 180 ival = k RETURN END IF RETURN END FUNCTION random_Poisson","tags":"","loc":"proc/random_poisson.html"},{"title":"random_binomial1 – Fortran free function collection","text":"public  function random_binomial1(n, p, first) result(ival) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: p logical, intent(in) :: first Return Value integer Contents Source Code random_binomial1 Source Code FUNCTION random_binomial1 ( n , p , first ) RESULT ( ival ) ! FUNCTION GENERATES A RANDOM BINOMIAL VARIATE USING C.D.Kemp's method. ! This algorithm is suitable when many random variates are required ! with the SAME parameter values for n & p. !    P = BERNOULLI SUCCESS PROBABILITY !           (0 <= REAL <= 1) !    N = NUMBER OF BERNOULLI TRIALS !           (1 <= INTEGER) !    FIRST = .TRUE. for the first call using the current parameter values !          = .FALSE. if the values of (n,p) are unchanged from last call ! Reference: Kemp, C.D. (1986). `A modal method for generating binomial !            variables', Commun. Statist. - Theor. Meth. 15(3), 805-813. INTEGER , INTENT ( IN ) :: n REAL , INTENT ( IN ) :: p LOGICAL , INTENT ( IN ) :: first INTEGER :: ival !     Local variables INTEGER :: ru , rd INTEGER , SAVE :: r0 REAL :: u , pd , pu REAL , SAVE :: odds_ratio , p_r REAL , PARAMETER :: zero = 0.0 , one = 1.0 IF ( first ) THEN r0 = ( n + 1 ) * p p_r = bin_prob ( n , p , r0 ) odds_ratio = p / ( one - p ) END IF CALL RANDOM_NUMBER ( u ) u = u - p_r IF ( u < zero ) THEN ival = r0 RETURN END IF pu = p_r ru = r0 pd = p_r rd = r0 DO rd = rd - 1 IF ( rd >= 0 ) THEN pd = pd * ( rd + 1 ) / ( odds_ratio * ( n - rd )) u = u - pd IF ( u < zero ) THEN ival = rd RETURN END IF END IF ru = ru + 1 IF ( ru <= n ) THEN pu = pu * ( n - ru + 1 ) * odds_ratio / ru u = u - pu IF ( u < zero ) THEN ival = ru RETURN END IF END IF END DO !     This point should not be reached, but just in case: ival = r0 RETURN END FUNCTION random_binomial1","tags":"","loc":"proc/random_binomial1.html"},{"title":"bin_prob – Fortran free function collection","text":"public  function bin_prob(n, p, r) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: p integer, intent(in) :: r Return Value real Contents Source Code bin_prob Source Code FUNCTION bin_prob ( n , p , r ) RESULT ( fn_val ) !     Calculate a binomial probability INTEGER , INTENT ( IN ) :: n , r REAL , INTENT ( IN ) :: p REAL :: fn_val !     Local variable REAL :: one = 1.0 fn_val = EXP ( lngamma ( DBLE ( n + 1 )) - lngamma ( DBLE ( r + 1 )) - lngamma ( DBLE ( n - r + 1 )) & + r * LOG ( p ) + ( n - r ) * LOG ( one - p ) ) RETURN END FUNCTION bin_prob","tags":"","loc":"proc/bin_prob.html"},{"title":"lngamma – Fortran free function collection","text":"public  function lngamma(x) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents Source Code lngamma Source Code FUNCTION lngamma ( x ) RESULT ( fn_val ) ! Logarithm to base e of the gamma function. ! ! Accurate to about 1.e-14. ! Programmer: Alan Miller ! Latest revision of Fortran 77 version - 28 February 1988 REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val !       Local variables REAL ( dp ) :: a1 = - 4.166666666554424D-02 , a2 = 2.430554511376954D-03 , & a3 = - 7.685928044064347D-04 , a4 = 5.660478426014386D-04 , & temp , arg , product , lnrt2pi = 9.189385332046727D-1 , & pi = 3.141592653589793D0 LOGICAL :: reflect !       lngamma is not defined if x = 0 or a negative integer. IF ( x > 0.d0 ) GO TO 10 IF ( x /= INT ( x )) GO TO 10 fn_val = 0.d0 RETURN !       If x < 0, use the reflection formula: !               gamma(x) * gamma(1-x) = pi * cosec(pi.x) 10 reflect = ( x < 0.d0 ) IF ( reflect ) THEN arg = 1.d0 - x ELSE arg = x END IF !       Increase the argument, if necessary, to make it > 10. product = 1.d0 20 IF ( arg <= 1 0.d0 ) THEN product = product * arg arg = arg + 1.d0 GO TO 20 END IF !  Use a polynomial approximation to Stirling's formula. !  N.B. The real Stirling's formula is used here, not the simpler, but less !       accurate formula given by De Moivre in a letter to Stirling, which !       is the one usually quoted. arg = arg - 0.5D0 temp = 1.d0 / arg ** 2 fn_val = lnrt2pi + arg * ( LOG ( arg ) - 1.d0 + & ((( a4 * temp + a3 ) * temp + a2 ) * temp + a1 ) * temp ) - LOG ( product ) IF ( reflect ) THEN temp = SIN ( pi * x ) fn_val = LOG ( pi / temp ) - fn_val END IF RETURN END FUNCTION lngamma","tags":"","loc":"proc/lngamma.html"},{"title":"random_binomial2 – Fortran free function collection","text":"public  function random_binomial2(n, pp, first) result(ival) Translated to Fortran 90 by Alan Miller from : RANLIB Library of Fortran Routines for Random Number Generation Compiled and Written by : Barry W . Brown James Lovato Department of Biomathematics , Box 237 The University of Texas , M . D . Anderson Cancer Center 1515 Holcombe Boulevard Houston , TX 77030 This work was supported by grant CA-16672 from the National Cancer Institute. ****DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY ****GENERATE VARIATE, Binomial mean at least 30. ****DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: pp logical, intent(in) :: first Return Value integer Contents Source Code random_binomial2 Source Code FUNCTION random_binomial2 ( n , pp , first ) RESULT ( ival ) !********************************************************************** !     Translated to Fortran 90 by Alan Miller from: !                              RANLIB ! !     Library of Fortran Routines for Random Number Generation ! !                      Compiled and Written by: ! !                           Barry W. Brown !                            James Lovato ! !               Department of Biomathematics, Box 237 !               The University of Texas, M.D. Anderson Cancer Center !               1515 Holcombe Boulevard !               Houston, TX      77030 ! ! This work was supported by grant CA-16672 from the National Cancer Institute. !                    GENerate BINomial random deviate !                              Function !     Generates a single random deviate from a binomial !     distribution whose number of trials is N and whose !     probability of an event in each trial is P. !                              Arguments !     N  --> The number of trials in the binomial distribution !            from which a random deviate is to be generated. !                              INTEGER N !     P  --> The probability of an event in each trial of the !            binomial distribution from which a random deviate !            is to be generated. !                              REAL P !     FIRST --> Set FIRST = .TRUE. for the first call to perform initialization !               the set FIRST = .FALSE. for further calls using the same pair !               of parameter values (N, P). !                              LOGICAL FIRST !     random_binomial2 <-- A random deviate yielding the number of events !                from N independent trials, each of which has !                a probability of event P. !                              INTEGER random_binomial !                              Method !     This is algorithm BTPE from: !         Kachitvichyanukul, V. and Schmeiser, B. W. !         Binomial Random Variate Generation. !         Communications of the ACM, 31, 2 (February, 1988) 216. !********************************************************************** !*****DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY !     .. !     .. Scalar Arguments .. REAL , INTENT ( IN ) :: pp INTEGER , INTENT ( IN ) :: n LOGICAL , INTENT ( IN ) :: first INTEGER :: ival !     .. !     .. Local Scalars .. REAL :: alv , amaxp , f , f1 , f2 , u , v , w , w2 , x , x1 , x2 , ynorm , z , z2 REAL , PARAMETER :: zero = 0.0 , half = 0.5 , one = 1.0 INTEGER :: i , ix , ix1 , k , mp INTEGER , SAVE :: m REAL , SAVE :: p , q , xnp , ffm , fm , xnpq , p1 , xm , xl , xr , c , al , xll , & xlr , p2 , p3 , p4 , qn , r , g !     .. !     .. Executable Statements .. !*****SETUP, PERFORM ONLY WHEN PARAMETERS CHANGE IF ( first ) THEN p = MIN ( pp , one - pp ) q = one - p xnp = n * p END IF IF ( xnp > 3 0. ) THEN IF ( first ) THEN ffm = xnp + p m = ffm fm = m xnpq = xnp * q p1 = INT ( 2.195 * SQRT ( xnpq ) - 4.6 * q ) + half xm = fm + half xl = xm - p1 xr = xm + p1 c = 0.134 + 2 0.5 / ( 1 5.3 + fm ) al = ( ffm - xl ) / ( ffm - xl * p ) xll = al * ( one + half * al ) al = ( xr - ffm ) / ( xr * q ) xlr = al * ( one + half * al ) p2 = p1 * ( one + c + c ) p3 = p2 + c / xll p4 = p3 + c / xlr END IF !*****GENERATE VARIATE, Binomial mean at least 30. 20 CALL RANDOM_NUMBER ( u ) u = u * p4 CALL RANDOM_NUMBER ( v ) !     TRIANGULAR REGION IF ( u <= p1 ) THEN ix = xm - p1 * v + u GO TO 110 END IF !     PARALLELOGRAM REGION IF ( u <= p2 ) THEN x = xl + ( u - p1 ) / c v = v * c + one - ABS ( xm - x ) / p1 IF ( v > one . OR . v <= zero ) GO TO 20 ix = x ELSE !     LEFT TAIL IF ( u <= p3 ) THEN ix = xl + LOG ( v ) / xll IF ( ix < 0 ) GO TO 20 v = v * ( u - p2 ) * xll ELSE !     RIGHT TAIL ix = xr - LOG ( v ) / xlr IF ( ix > n ) GO TO 20 v = v * ( u - p3 ) * xlr END IF END IF !*****DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST k = ABS ( ix - m ) IF ( k <= 20 . OR . k >= xnpq / 2 - 1 ) THEN !     EXPLICIT EVALUATION f = one r = p / q g = ( n + 1 ) * r IF ( m < ix ) THEN mp = m + 1 DO i = mp , ix f = f * ( g / i - r ) END DO ELSE IF ( m > ix ) THEN ix1 = ix + 1 DO i = ix1 , m f = f / ( g / i - r ) END DO END IF IF ( v > f ) THEN GO TO 20 ELSE GO TO 110 END IF END IF !     SQUEEZING USING UPPER AND LOWER BOUNDS ON LOG(F(X)) amaxp = ( k / xnpq ) * (( k * ( k / 3. + . 625 ) + . 1666666666666 ) / xnpq + half ) ynorm = - k * k / ( 2. * xnpq ) alv = LOG ( v ) IF ( alv < ynorm - amaxp ) GO TO 110 IF ( alv > ynorm + amaxp ) GO TO 20 !     STIRLING'S (actually de Moivre's) FORMULA TO MACHINE ACCURACY FOR !     THE FINAL ACCEPTANCE/REJECTION TEST x1 = ix + 1 f1 = fm + one z = n + 1 - fm w = n - ix + one z2 = z * z x2 = x1 * x1 f2 = f1 * f1 w2 = w * w IF ( alv - ( xm * LOG ( f1 / x1 ) + ( n - m + half ) * LOG ( z / w ) + ( ix - m ) * LOG ( w * p / ( x1 * q )) + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / f2 ) / f2 ) / f2 ) / f2 ) / f1 / 16632 0. + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / z2 ) / z2 ) / z2 ) / z2 ) / z / 16632 0. + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / x2 ) / x2 ) / x2 ) / x2 ) / x1 / 16632 0. + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / w2 ) / w2 ) / w2 ) / w2 ) / w / 16632 0. ) > zero ) THEN GO TO 20 ELSE GO TO 110 END IF ELSE !     INVERSE CDF LOGIC FOR MEAN LESS THAN 30 IF ( first ) THEN qn = q ** n r = p / q g = r * ( n + 1 ) END IF 90 ix = 0 f = qn CALL RANDOM_NUMBER ( u ) 100 IF ( u >= f ) THEN IF ( ix > 110 ) GO TO 90 u = u - f ix = ix + 1 f = f * ( g / ix - r ) GO TO 100 END IF END IF 110 IF ( pp > half ) ix = n - ix ival = ix RETURN END FUNCTION random_binomial2","tags":"","loc":"proc/random_binomial2.html"},{"title":"random_neg_binomial – Fortran free function collection","text":"public  function random_neg_binomial(sk, p) result(ival) Arguments Type Intent Optional Attributes Name real, intent(in) :: sk real, intent(in) :: p Return Value integer Contents Source Code random_neg_binomial Source Code FUNCTION random_neg_binomial ( sk , p ) RESULT ( ival ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM NEGATIVE BINOMIAL VARIATE USING UNSTORED ! INVERSION AND/OR THE REPRODUCTIVE PROPERTY. !    SK = NUMBER OF FAILURES REQUIRED (Dagpunar's words!) !       = the `power' parameter of the negative binomial !           (0 < REAL) !    P = BERNOULLI SUCCESS PROBABILITY !           (0 < REAL < 1) ! THE PARAMETER H IS SET SO THAT UNSTORED INVERSION ONLY IS USED WHEN P <= H, ! OTHERWISE A COMBINATION OF UNSTORED INVERSION AND ! THE REPRODUCTIVE PROPERTY IS USED. REAL , INTENT ( IN ) :: sk , p INTEGER :: ival !     Local variables ! THE PARAMETER ULN = -LOG(MACHINE'S SMALLEST REAL NUMBER). REAL , PARAMETER :: h = 0.7 REAL :: q , x , st , uln , v , r , s , y , g INTEGER :: k , i , n IF ( sk <= zero . OR . p <= zero . OR . p >= one ) THEN WRITE ( * , * ) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' STOP END IF q = one - p x = zero st = sk IF ( p > h ) THEN v = one / LOG ( p ) k = st DO i = 1 , k DO CALL RANDOM_NUMBER ( r ) IF ( r > zero ) EXIT END DO n = v * LOG ( r ) x = x + n END DO st = st - k END IF s = zero uln = - LOG ( vsmall ) IF ( st > - uln / LOG ( q )) THEN WRITE ( * , * ) ' P IS TOO LARGE FOR THIS VALUE OF SK' STOP END IF y = q ** st g = st CALL RANDOM_NUMBER ( r ) DO IF ( y > r ) EXIT r = r - y s = s + one y = y * p * g / s g = g + one END DO ival = x + s + half RETURN END FUNCTION random_neg_binomial","tags":"","loc":"proc/random_neg_binomial.html"},{"title":"random_von_Mises – Fortran free function collection","text":"public  function random_von_Mises(k, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: k logical, intent(in) :: first Return Value real Contents Source Code random_von_Mises Source Code FUNCTION random_von_Mises ( k , first ) RESULT ( fn_val ) !     Algorithm VMD from: !     Dagpunar, J.S. (1990) `Sampling from the von Mises distribution via a !     comparison of random numbers', J. of Appl. Statist., 17, 165-168. !     Fortran 90 code by Alan Miller !     CSIRO Division of Mathematical & Information Sciences !     Arguments: !     k (real)        parameter of the von Mises distribution. !     first (logical) set to .TRUE. the first time that the function !                     is called, or the first time with a new value !                     for k.   When first = .TRUE., the function sets !                     up starting values and may be very much slower. REAL , INTENT ( IN ) :: k LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables INTEGER :: j , n INTEGER , SAVE :: nk REAL , PARAMETER :: pi = 3.14159265 REAL , SAVE :: p ( 20 ), theta ( 0 : 20 ) REAL :: sump , r , th , lambda , rlast REAL ( dp ) :: dk IF ( first ) THEN ! Initialization, if necessary IF ( k < zero ) THEN WRITE ( * , * ) '** Error: argument k for random_von_Mises = ' , k RETURN END IF nk = k + k + one IF ( nk > 20 ) THEN WRITE ( * , * ) '** Error: argument k for random_von_Mises = ' , k RETURN END IF dk = k theta ( 0 ) = zero IF ( k > half ) THEN !     Set up array p of probabilities. sump = zero DO j = 1 , nk IF ( j < nk ) THEN theta ( j ) = ACOS ( one - j / k ) ELSE theta ( nk ) = pi END IF !     Numerical integration of e&#94;[k.cos(x)] from theta(j-1) to theta(j) CALL integral ( theta ( j - 1 ), theta ( j ), p ( j ), dk ) sump = sump + p ( j ) END DO p ( 1 : nk ) = p ( 1 : nk ) / sump ELSE p ( 1 ) = one theta ( 1 ) = pi END IF ! if k > 0.5 END IF ! if first CALL RANDOM_NUMBER ( r ) DO j = 1 , nk r = r - p ( j ) IF ( r < zero ) EXIT END DO r = - r / p ( j ) DO th = theta ( j - 1 ) + r * ( theta ( j ) - theta ( j - 1 )) lambda = k - j + one - k * COS ( th ) n = 1 rlast = lambda DO CALL RANDOM_NUMBER ( r ) IF ( r > rlast ) EXIT n = n + 1 rlast = r END DO IF ( n . NE . 2 * ( n / 2 )) EXIT ! is n even? CALL RANDOM_NUMBER ( r ) END DO fn_val = SIGN ( th , ( r - rlast ) / ( one - rlast ) - half ) RETURN END FUNCTION random_von_Mises","tags":"","loc":"proc/random_von_mises.html"},{"title":"random_Cauchy – Fortran free function collection","text":"public  function random_Cauchy() result(fn_val) Arguments None Return Value real Contents Source Code random_Cauchy Source Code FUNCTION random_Cauchy () RESULT ( fn_val ) !     Generate a random deviate from the standard Cauchy distribution REAL :: fn_val !     Local variables REAL :: v ( 2 ) DO CALL RANDOM_NUMBER ( v ) v = two * ( v - half ) IF ( ABS ( v ( 2 )) < vsmall ) CYCLE ! Test for zero IF ( v ( 1 ) ** 2 + v ( 2 ) ** 2 < one ) EXIT END DO fn_val = v ( 1 ) / v ( 2 ) RETURN END FUNCTION random_Cauchy","tags":"","loc":"proc/random_cauchy.html"},{"title":"random_mvnorm – Fortran free function collection","text":"public  subroutine random_mvnorm(n, h, d, f, first, x, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: h (:) real, intent(in) :: d (:) real, intent(inout) :: f (:) logical, intent(in) :: first real, intent(out) :: x (:) integer, intent(out) :: ier Contents Source Code random_mvnorm Source Code SUBROUTINE random_mvnorm ( n , h , d , f , first , x , ier ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! N.B. An extra argument, ier, has been added to Dagpunar's routine !     SUBROUTINE GENERATES AN N VARIATE RANDOM NORMAL !     VECTOR USING A CHOLESKY DECOMPOSITION. ! ARGUMENTS: !        N = NUMBER OF VARIATES IN VECTOR !           (INPUT,INTEGER >= 1) !     H(J) = J'TH ELEMENT OF VECTOR OF MEANS !           (INPUT,REAL) !     X(J) = J'TH ELEMENT OF DELIVERED VECTOR !           (OUTPUT,REAL) ! !    D(J*(J-1)/2+I) = (I,J)'TH ELEMENT OF VARIANCE MATRIX (J> = I) !            (INPUT,REAL) !    F((J-1)*(2*N-J)/2+I) = (I,J)'TH ELEMENT OF LOWER TRIANGULAR !           DECOMPOSITION OF VARIANCE MATRIX (J <= I) !            (OUTPUT,REAL) !    FIRST = .TRUE. IF THIS IS THE FIRST CALL OF THE ROUTINE !    OR IF THE DISTRIBUTION HAS CHANGED SINCE THE LAST CALL OF THE ROUTINE. !    OTHERWISE SET TO .FALSE. !            (INPUT,LOGICAL) !    ier = 1 if the input covariance matrix is not +ve definite !        = 0 otherwise INTEGER , INTENT ( IN ) :: n REAL , INTENT ( IN ) :: h (:), d (:) ! d(n*(n+1)/2) REAL , INTENT ( IN OUT ) :: f (:) ! f(n*(n+1)/2) REAL , INTENT ( OUT ) :: x (:) LOGICAL , INTENT ( IN ) :: first INTEGER , INTENT ( OUT ) :: ier !     Local variables INTEGER :: j , i , m REAL :: y , v INTEGER , SAVE :: n2 IF ( n < 1 ) THEN WRITE ( * , * ) 'SIZE OF VECTOR IS NON POSITIVE' STOP END IF ier = 0 IF ( first ) THEN ! Initialization, if necessary n2 = 2 * n IF ( d ( 1 ) < zero ) THEN ier = 1 RETURN END IF f ( 1 ) = SQRT ( d ( 1 )) y = one / f ( 1 ) DO j = 2 , n f ( j ) = d ( 1 + j * ( j - 1 ) / 2 ) * y END DO DO i = 2 , n v = d ( i * ( i - 1 ) / 2 + i ) DO m = 1 , i - 1 v = v - f (( m - 1 ) * ( n2 - m ) / 2 + i ) ** 2 END DO IF ( v < zero ) THEN ier = 1 RETURN END IF v = SQRT ( v ) y = one / v f (( i - 1 ) * ( n2 - i ) / 2 + i ) = v DO j = i + 1 , n v = d ( j * ( j - 1 ) / 2 + i ) DO m = 1 , i - 1 v = v - f (( m - 1 ) * ( n2 - m ) / 2 + i ) * f (( m - 1 ) * ( n2 - m ) / 2 + j ) END DO ! m = 1,i-1 f (( i - 1 ) * ( n2 - i ) / 2 + j ) = v * y END DO ! j = i+1,n END DO ! i = 2,n END IF x ( 1 : n ) = h ( 1 : n ) DO j = 1 , n y = random_normal () DO i = j , n x ( i ) = x ( i ) + f (( j - 1 ) * ( n2 - j ) / 2 + i ) * y END DO ! i = j,n END DO ! j = 1,n RETURN END SUBROUTINE random_mvnorm","tags":"","loc":"proc/random_mvnorm.html"},{"title":"random_order – Fortran free function collection","text":"public  subroutine random_order(order, n) Arguments Type Intent Optional Attributes Name integer, intent(out) :: order (n) integer, intent(in) :: n Contents Source Code random_order Source Code SUBROUTINE random_order ( order , n ) !     Generate a random ordering of the integers 1 ... n. INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( OUT ) :: order ( n ) !     Local variables INTEGER :: i , j , k REAL :: wk DO i = 1 , n order ( i ) = i END DO !     Starting at the end, swap the current last indicator with one !     randomly chosen from those preceeding it. DO i = n , 2 , - 1 CALL RANDOM_NUMBER ( wk ) j = 1 + int ( i * wk ) IF ( j < i ) THEN k = order ( i ) order ( i ) = order ( j ) order ( j ) = k END IF END DO RETURN END SUBROUTINE random_order","tags":"","loc":"proc/random_order.html"},{"title":"seed_random_number – Fortran free function collection","text":"public  subroutine seed_random_number(iounit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iounit Contents Source Code seed_random_number Source Code SUBROUTINE seed_random_number ( iounit ) INTEGER , INTENT ( IN ) :: iounit ! Local variables INTEGER :: k INTEGER , ALLOCATABLE :: seed (:) CALL RANDOM_SEED ( SIZE = k ) ALLOCATE ( seed ( k ) ) WRITE ( * , '(a, i2, a)' ) ' Enter ' , k , ' integers for random no. seeds: ' READ ( * , * ) seed WRITE ( iounit , '(a, (7i10))' ) ' Random no. seeds: ' , seed CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) RETURN END SUBROUTINE seed_random_number","tags":"","loc":"proc/seed_random_number.html"},{"title":"randn – Fortran free function collection","text":"interface public impure elemental module subroutine randn(x, mean, std) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(out) :: x real(kind=fffc_real_kind), intent(in) :: mean real(kind=fffc_real_kind), intent(in) :: std","tags":"","loc":"interface/randn.html"},{"title":"randu – Fortran free function collection","text":"interface public impure elemental module subroutine randu(x, min, max) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(out) :: x real(kind=fffc_real_kind), intent(in) :: min real(kind=fffc_real_kind), intent(in) :: max","tags":"","loc":"interface/randu.html"},{"title":"to_string – Fortran free function collection","text":"public interface to_string Contents Functions to_string_real_kind to_string_int_kind to_string_logical_kind Functions public module function to_string_real_kind(real, fmt) result(string) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: real character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable public module function to_string_int_kind(int, fmt) result(string) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: int character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable public module function to_string_logical_kind(logical, fmt) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable","tags":"","loc":"interface/to_string.html"},{"title":"to_lower – Fortran free function collection","text":"interface public pure module function to_lower(string) result(lower) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len)","tags":"","loc":"interface/to_lower.html"},{"title":"to_upper – Fortran free function collection","text":"interface public pure module function to_upper(string) result(upper) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len)","tags":"","loc":"interface/to_upper.html"},{"title":"inv – Fortran free function collection","text":"public interface inv Contents Subroutines inv_real_kind inv_complex_kind Subroutines public module subroutine inv_real_kind(a) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a (:,:) public module subroutine inv_complex_kind(a) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(inout) :: a (:,:)","tags":"","loc":"interface/inv.html"},{"title":"inv_func – Fortran free function collection","text":"public interface inv_func Contents Functions inv_func_real_kind inv_func_complex_kind Functions public module function inv_func_real_kind(a) result(b) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) Return Value real(kind=fffc_real_kind), (size(a,1),size(a,2)) public module function inv_func_complex_kind(a) result(b) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(a,2))","tags":"","loc":"interface/inv_func.html"},{"title":"linv – Fortran free function collection","text":"public interface linv m > n, 列满秩，使用 linv Contents Functions linv_real_kind linv_complex_kind Functions public module function linv_real_kind(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:,:) Return Value real(kind=fffc_real_kind), (size(x,2),size(x,1)) public module function linv_complex_kind(x) result(y) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: x (:,:) Return Value complex(kind=fffc_complex_kind), (size(x,2),size(x,1))","tags":"","loc":"interface/linv.html"},{"title":"rinv – Fortran free function collection","text":"public interface rinv m < n, 行满秩，使用 rinv Contents Functions rinv_real_kind rinv_complex_kind Functions public module function rinv_real_kind(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:,:) Return Value real(kind=fffc_real_kind), (size(x,2),size(x,1)) public module function rinv_complex_kind(x) result(y) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: x (:,:) Return Value complex(kind=fffc_complex_kind), (size(x,2),size(x,1))","tags":"","loc":"interface/rinv.html"},{"title":"solve – Fortran free function collection","text":"public interface solve Contents Subroutines solve_real_kind solve_complex_kind Subroutines public module subroutine solve_real_kind(a, b) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a (:,:) real(kind=fffc_real_kind), intent(inout) :: b (:,:) public module subroutine solve_complex_kind(a, b) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(inout) :: a (:,:) complex(kind=fffc_complex_kind), intent(inout) :: b (:,:)","tags":"","loc":"interface/solve.html"},{"title":"solve_func – Fortran free function collection","text":"public interface solve_func Contents Functions solve_func_real_kind solve_func_complex_kind Functions public module function solve_func_real_kind(a, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) real(kind=fffc_real_kind), intent(in) :: b (:,:) Return Value real(kind=fffc_real_kind), (size(b,1),size(b,2)) public module function solve_func_complex_kind(a, b) result(x) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) complex(kind=fffc_complex_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(b,1),size(b,2))","tags":"","loc":"interface/solve_func.html"},{"title":"diag – Fortran free function collection","text":"public interface diag Contents Functions diag_rank1 diag_rank2 Functions public pure module function diag_rank1(v) result(a) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: v (:) Return Value real(kind=fffc_real_kind), (size(v),size(v)) public pure module function diag_rank2(a) result(v) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) Return Value real(kind=fffc_real_kind), (min(size(a,1),size(a,2)))","tags":"","loc":"interface/diag.html"},{"title":"gemm – Fortran free function collection","text":"public interface gemm Contents Functions rrgemm ccgemm crgemm rcgemm Functions public module function rrgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) real(kind=fffc_real_kind), intent(in) :: b (:,:) Return Value real(kind=fffc_real_kind), (size(a,1),size(b,2)) public module function ccgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) complex(kind=fffc_complex_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(b,2)) public module function crgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) real(kind=fffc_real_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(b,2)) public module function rcgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) complex(kind=fffc_complex_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(b,2))","tags":"","loc":"interface/gemm.html"},{"title":"det – Fortran free function collection","text":"interface public module function det(a) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a (:,:) Return Value real(kind=fffc_real_kind)","tags":"","loc":"interface/det.html"},{"title":"eye – Fortran free function collection","text":"interface public pure module function eye(m, n) result(a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer(kind=int8)(m,n)","tags":"","loc":"interface/eye.html"},{"title":"is_windows – Fortran free function collection","text":"interface public module function is_windows() Arguments None Return Value logical","tags":"","loc":"interface/is_windows.html"},{"title":"exists – Fortran free function collection","text":"interface public module function exists(file, is_directory) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file logical, intent(in), optional :: is_directory Return Value logical","tags":"","loc":"interface/exists.html"},{"title":"countlines – Fortran free function collection","text":"interface public module function countlines(file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer","tags":"","loc":"interface/countlines.html"},{"title":"unix_path – Fortran free function collection","text":"interface public pure module function unix_path(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=len)","tags":"","loc":"interface/unix_path.html"},{"title":"dirname – Fortran free function collection","text":"interface public pure module function dirname(path) result(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),allocatable","tags":"","loc":"interface/dirname.html"},{"title":"basename – Fortran free function collection","text":"interface public pure module function basename(path) result(base) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:),allocatable","tags":"","loc":"interface/basename.html"},{"title":"mkdir – Fortran free function collection","text":"interface public module subroutine mkdir(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path","tags":"","loc":"interface/mkdir.html"},{"title":"rmdir – Fortran free function collection","text":"interface public module subroutine rmdir(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path","tags":"","loc":"interface/rmdir.html"},{"title":"operator(.join.) – Fortran free function collection","text":"public interface operator(.join.) Contents Functions join Functions public module function join(path, name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path character(len=*), intent(in) :: name Return Value character(len=len)","tags":"","loc":"interface/operator(.join.).html"},{"title":"mean – Fortran free function collection","text":"public interface mean Contents Functions mean_real_kind mean_int_kind Functions public pure module function mean_real_kind(x) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:) Return Value real(kind=fffc_real_kind) public pure module function mean_int_kind(x) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: x (:) Return Value integer(kind=fffc_int_kind)","tags":"","loc":"interface/mean.html"},{"title":"swap – Fortran free function collection","text":"public interface swap Contents Subroutines swap_int_kind swap_real_kind Subroutines public elemental module subroutine swap_int_kind(a, b) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(inout) :: a integer(kind=fffc_int_kind), intent(inout) :: b public elemental module subroutine swap_real_kind(a, b) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a real(kind=fffc_real_kind), intent(inout) :: b","tags":"","loc":"interface/swap.html"},{"title":"bubble_sort – Fortran free function collection","text":"public interface bubble_sort Contents Subroutines bubble_sort_real_kind bubble_sort_int_kind Subroutines public pure module subroutine bubble_sort_real_kind(v) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: v (:) public pure module subroutine bubble_sort_int_kind(v) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(inout) :: v (:)","tags":"","loc":"interface/bubble_sort.html"},{"title":"is_env – Fortran free function collection","text":"interface public module function is_env(key) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value logical","tags":"","loc":"interface/is_env.html"},{"title":"cross_product – Fortran free function collection","text":"public interface cross_product Contents Functions cross_product_real_kind cross_product_int_kind Functions public pure module function cross_product_real_kind(v1, v2) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: v1 (3) real(kind=fffc_real_kind), intent(in) :: v2 (3) Return Value real(kind=fffc_real_kind), (3) public pure module function cross_product_int_kind(v1, v2) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: v1 (3) integer(kind=fffc_int_kind), intent(in) :: v2 (3) Return Value integer(kind=fffc_int_kind), (3)","tags":"","loc":"interface/cross_product.html"},{"title":"arange – Fortran free function collection","text":"public interface arange Contents Functions arange_real_kind arange_int_kind Functions public pure module function arange_real_kind(start, stop, step) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: start real(kind=fffc_real_kind), intent(in) :: stop real(kind=fffc_real_kind), intent(in), optional :: step Return Value real(kind=fffc_real_kind), allocatable, (:) public pure module function arange_int_kind(start, stop, step) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: start integer(kind=fffc_int_kind), intent(in) :: stop integer(kind=fffc_int_kind), intent(in), optional :: step Return Value integer(kind=fffc_int_kind), allocatable, (:)","tags":"","loc":"interface/arange.html"},{"title":"diff – Fortran free function collection","text":"public interface diff Contents Functions diff_real_kind diff_int_kind Functions public pure module function diff_real_kind(x, n, prepend, append) result(y) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:) integer, intent(in), optional :: n real(kind=fffc_real_kind), intent(in), optional :: prepend (:) real(kind=fffc_real_kind), intent(in), optional :: append (:) Return Value real(kind=fffc_real_kind), allocatable, (:) public pure module function diff_int_kind(x, n, prepend, append) result(y) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: x (:) integer, intent(in), optional :: n integer(kind=fffc_int_kind), intent(in), optional :: prepend (:) integer(kind=fffc_int_kind), intent(in), optional :: append (:) Return Value integer(kind=fffc_int_kind), allocatable, (:)","tags":"","loc":"interface/diff.html"},{"title":"linspace – Fortran free function collection","text":"public interface linspace Contents Functions linspace_real_kind linspace_int_kind Functions public pure module function linspace_real_kind(start, stop, n) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: start real(kind=fffc_real_kind), intent(in) :: stop integer, intent(in) :: n Return Value real(kind=fffc_real_kind), (max(0,n)) public pure module function linspace_int_kind(start, stop, n) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: start integer(kind=fffc_int_kind), intent(in) :: stop integer, intent(in) :: n Return Value integer(kind=fffc_int_kind), (max(0,n))","tags":"","loc":"interface/linspace.html"},{"title":"arg – Fortran free function collection","text":"interface public elemental module function arg(z) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: z Return Value real(kind=fffc_real_kind)","tags":"","loc":"interface/arg.html"},{"title":"is_close – Fortran free function collection","text":"interface public elemental module function is_close(a, b, rel_tol, abs_tol, equal_nan) result(close) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a real(kind=fffc_real_kind), intent(in) :: b real(kind=fffc_real_kind), intent(in), optional :: rel_tol real(kind=fffc_real_kind), intent(in), optional :: abs_tol logical, intent(in), optional :: equal_nan Return Value logical","tags":"","loc":"interface/is_close.html"},{"title":"toc – Fortran free function collection","text":"public  function toc(self) Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: self Return Value real(kind=fffc_real_kind) Contents Source Code toc Source Code function toc ( self ) class ( timer ), intent ( in ) :: self real ( kind = fffc_real_kind ) :: toc integer :: time_now , time_rate call system_clock ( time_now , time_rate ) toc = real ( time_now - self % seed , fffc_real_kind ) / time_rate end function toc","tags":"","loc":"proc/toc.html"},{"title":"nowtime – Fortran free function collection","text":"public  function nowtime(self) result(t) Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: self Return Value character(len=23) Contents Source Code nowtime Source Code character ( 23 ) function nowtime ( self ) result ( t ) class ( timer ), intent ( in ) :: self character ( len = 8 ) :: datstr character ( len = 10 ) :: timstr call date_and_time ( datstr , timstr ) t = datstr ( 1 : 4 ) // \"-\" // datstr ( 5 : 6 ) // \"-\" // datstr ( 7 : 8 ) // \" \" // & timstr ( 1 : 2 ) // \":\" // timstr ( 3 : 4 ) // \":\" // timstr ( 5 : 10 ) end function nowtime","tags":"","loc":"proc/nowtime.html"},{"title":"tic – Fortran free function collection","text":"public  subroutine tic(self) Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(out) :: self Contents Source Code tic Source Code subroutine tic ( self ) class ( timer ), intent ( out ) :: self call system_clock ( self % seed ) end subroutine tic","tags":"","loc":"proc/tic.html"},{"title":"rkf45 – Fortran free function collection","text":"public  subroutine rkf45(f, neqn, y, t, tout, relerr, abserr, iflag, work, iwork) rkf45 is primarily designed to solve non-stiff and mildly stiff\ndifferential equations when derivative evaluations are inexpensive.\nrkf45 should generally not be used when the user is demanding\nhigh accuracy.\n在计算量不大的计算中，rkf45主要用于求解非刚性和轻微刚性的常微分方程。 Arguments Type Intent Optional Attributes Name procedure(fcn) :: f integer, intent(in) :: neqn real(kind=rk), intent(inout) :: y (neqn) real(kind=rk), intent(inout) :: t real(kind=rk), intent(in) :: tout real(kind=rk), intent(inout) :: relerr real(kind=rk), intent(in) :: abserr integer, intent(inout) :: iflag real(kind=rk), intent(inout) :: work (*) integer, intent(inout) :: iwork (5) Contents Source Code rkf45 Source Code subroutine rkf45 ( f , neqn , y , t , tout , relerr , abserr , iflag , work , iwork ) !     fehlberg fourth-fifth order runge-kutta method !     written by h.a.watts and l.f.shampine !                   sandia laboratories !                  albuquerque,new mexico ! abstract !    subroutine  rkf45  integrates a system of neqn first order !    ordinary differential equations of the form !             dy(i)/dt = f(t,y(1),y(2),...,y(neqn)) !              where the y(i) are given at t . !    typically the subroutine is used to integrate from t to tout but it !    can be used as a one-step integrator to advance the solution a !    single step in the direction of tout.  on return the parameters in !    the call list are set for continuing the integration. the user has !    only to call rkf45 again (and perhaps define a new value for tout). !    actually, rkf45 is an interfacing routine which calls subroutine !    rkfs for the solution.  rkfs in turn calls subroutine  fehl which !    computes an approximate solution over one step. !    rkf45  uses the runge-kutta-fehlberg (4,5)  method described !    in the reference !    e.fehlberg , low-order classical runge-kutta formulas with stepsize !                 control , nasa tr r-315 !    the performance of rkf45 is illustrated in the reference !    l.f.shampine,h.a.watts,s.davenport, solving non-stiff ordinary !                 differential equations-the state of the art , !                 sandia laboratories report sand75-0182 , !                 to appear in siam review. !    the parameters represent- !      f -- subroutine f(t,y,yp) to evaluate derivatives yp(i)=dy(i)/dt !      neqn -- number of equations to be integrated !      y(*) -- solution vector at t !      t -- independent variable !      tout -- output point at which solution is desired !      relerr,abserr -- relative and absolute error tolerances for local !            error test. at each step the code requires that !                 abs(local error) .le. relerr*abs(y) + abserr !            for each component of the local error and solution vectors !      iflag -- indicator for status of integration !      work(*) -- array to hold information internal to rkf45 which is !            necessary for subsequent calls. must be dimensioned !            at least  3+6*neqn !      iwork(*) -- integer array used to hold information internal to !            rkf45 which is necessary for subsequent calls. must be !            dimensioned at least  5 !  first call to rkf45 !    the user must provide storage in his calling program for the arrays !    in the call list  -      y(neqn) , work(3+6*neqn) , iwork(5)  , !    declare f in an external statement, supply subroutine f(t,y,yp) and !    initialize the following parameters- !      neqn -- number of equations to be integrated.  (neqn .ge. 1) !      y(*) -- vector of initial conditions !      t -- starting point of integration , must be a variable !      tout -- output point at which solution is desired. !            t=tout is allowed on the first call only, in which case !            rkf45 returns with iflag=2 if continuation is possible. !      relerr,abserr -- relative and absolute local error tolerances !            which must be non-negative. relerr must be a variable while !            abserr may be a constant. the code should normally not be !            used with relative error control smaller than about 1.e-8 . !            to avoid limiting precision difficulties the code requires !            relerr to be larger than an internally computed relative !            error parameter which is machine dependent. in particular, !            pure absolute error is not permitted. if a smaller than !            allowable value of relerr is attempted, rkf45 increases !            relerr appropriately and returns control to the user before !            continuing the integration. !      iflag -- +1,-1  indicator to initialize the code for each new !            problem. normal input is +1. the user should set iflag=-1 !            only when one-step integrator control is essential. in this !            case, rkf45 attempts to advance the solution a single step !            in the direction of tout each time it is called. since this !            mode of operation results in extra computing overhead, it !            should be avoided unless needed. !  output from rkf45 !      y(*) -- solution at t !      t -- last point reached in integration. !      iflag = 2 -- integration reached tout. indicates successful retur !                   and is the normal mode for continuing integration. !            =-2 -- a single successful step in the direction of tout !                   has been taken. normal mode for continuing !                   integration one step at a time. !            = 3 -- integration was not completed because relative error !                   tolerance was too small. relerr has been increased !                   appropriately for continuing. !            = 4 -- integration was not completed because more than !                   3000 derivative evaluations were needed. this !                   is approximately 500 steps. !            = 5 -- integration was not completed because solution !                   vanished making a pure relative error test !                   impossible. must use non-zero abserr to continue. !                   using the one-step integration mode for one step !                   is a good way to proceed. !            = 6 -- integration was not completed because requested !                   accuracy could not be achieved using smallest !                   allowable stepsize. user must increase the error !                   tolerance before continued integration can be !                   attempted. !            = 7 -- it is likely that rkf45 is inefficient for solving !                   this problem. too much output is restricting the !                   natural stepsize choice. use the one-step integrator !                   mode. !            = 8 -- invalid input parameters !                   this indicator occurs if any of the following is !                   satisfied -   neqn .le. 0 !                                 t=tout  and  iflag .ne. +1 or -1 !                                 relerr or abserr .lt. 0. !                                 iflag .eq. 0  or  .lt. -2  or  .gt. 8 !      work(*),iwork(*) -- information which is usually of no interest !                   to the user but necessary for subsequent calls. !                   work(1),...,work(neqn) contain the first derivatives !                   of the solution vector y at t. work(neqn+1) contains !                   the stepsize h to be attempted on the next step. !                   iwork(1) contains the derivative evaluation counter. !  subsequent calls to rkf45 !    subroutine rkf45 returns with all information needed to continue !    the integration. if the integration reached tout, the user need onl !    define a new tout and call rkf45 again. in the one-step integrator !    mode (iflag=-2) the user must keep in mind that each step taken is !    in the direction of the current tout. upon reaching tout (indicated !    by changing iflag to 2),the user must then define a new tout and !    reset iflag to -2 to continue in the one-step integrator mode. !    if the integration was not completed but the user still wants to !    continue (iflag=3,4 cases), he just calls rkf45 again. with iflag=3 !    the relerr parameter has been adjusted appropriately for continuing !    the integration. in the case of iflag=4 the function counter will !    be reset to 0 and another 3000 function evaluations are allowed. !    however,in the case iflag=5, the user must first alter the error !    criterion to use a positive value of abserr before integration can !    proceed. if he does not,execution is terminated. !    also,in the case iflag=6, it is necessary for the user to reset !    iflag to 2 (or -2 when the one-step integration mode is being used) !    as well as increasing either abserr,relerr or both before the !    integration can be continued. if this is not done, execution will !    be terminated. the occurrence of iflag=6 indicates a trouble spot !    (solution is changing rapidly,singularity may be present) and it !    often is inadvisable to continue. !    if iflag=7 is encountered, the user should use the one-step !    integration mode with the stepsize determined by the code or !    consider switching to the adams codes de/step,intrp. if the user !    insists upon continuing the integration with rkf45, he must reset !    iflag to 2 before calling rkf45 again. otherwise,execution will be !    terminated. !    if iflag=8 is obtained, integration can not be continued unless !    the invalid input parameters are corrected. !    it should be noted that the arrays work,iwork contain information !    required for subsequent integration. accordingly, work and iwork !    should not be altered. integer , intent ( in ) :: neqn real ( kind = rk ), intent ( inout ) :: y ( neqn ) real ( kind = rk ), intent ( inout ) :: t real ( kind = rk ), intent ( in ) :: tout integer , intent ( inout ) :: iflag , iwork ( 5 ) real ( kind = rk ), intent ( inout ) :: relerr , work ( * ) real ( kind = rk ), intent ( in ) :: abserr procedure ( fcn ) :: f integer :: k1 , k2 , k3 , k4 , k5 , k6 , k1m !     compute indices for the splitting of the work array k1m = neqn + 1 k1 = k1m + 1 k2 = k1 + neqn k3 = k2 + neqn k4 = k3 + neqn k5 = k4 + neqn k6 = k5 + neqn !     this interfacing routine merely relieves the user of a long !     calling list via the splitting apart of two working storage !     arrays. if this is not compatible with the users compiler, !     he must use rkfs directly. call rkfs ( f , neqn , y , t , tout , relerr , abserr , iflag , & work ( 1 ), work ( k1m ), work ( k1 ), work ( k2 ), work ( k3 ), work ( k4 ), work ( k5 ), work ( k6 ), work ( k6 + 1 ), & iwork ( 1 ), iwork ( 2 ), iwork ( 3 ), iwork ( 4 ), iwork ( 5 )) return end subroutine rkf45","tags":"","loc":"proc/rkf45.html"},{"title":"random – Fortran free function collection","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses fffc_kinds Contents Variables dp Functions random_normal random_gamma random_gamma1 random_gamma2 random_chisq random_exponential random_Weibull random_beta random_t random_inv_gauss random_Poisson random_binomial1 bin_prob lngamma random_binomial2 random_neg_binomial random_von_Mises random_Cauchy Subroutines random_mvnorm random_order seed_random_number Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = SELECTED_REAL_KIND(12, 60) Functions public  function random_normal () result(fn_val) Arguments None Return Value real public  function random_gamma (s, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: s logical, intent(in) :: first Return Value real public  function random_gamma1 (s, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: s logical, intent(in) :: first Return Value real public  function random_gamma2 (s, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: s logical, intent(in) :: first Return Value real public  function random_chisq (ndf, first) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndf logical, intent(in) :: first Return Value real public  function random_exponential () result(fn_val) Arguments None Return Value real public  function random_Weibull (a) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: a Return Value real public  function random_beta (aa, bb, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: aa real, intent(in) :: bb logical, intent(in) :: first Return Value real public  function random_t (m) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m Return Value real public  function random_inv_gauss (h, b, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: h real, intent(in) :: b logical, intent(in) :: first Return Value real public  function random_Poisson (mu, first) result(ival) This work was supported by grant CA-16672 from the National Cancer Institute. Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: mu logical, intent(in) :: first Return Value integer public  function random_binomial1 (n, p, first) result(ival) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: p logical, intent(in) :: first Return Value integer public  function bin_prob (n, p, r) result(fn_val) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: p integer, intent(in) :: r Return Value real public  function lngamma (x) result(fn_val) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public  function random_binomial2 (n, pp, first) result(ival) This work was supported by grant CA-16672 from the National Cancer Institute. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: pp logical, intent(in) :: first Return Value integer public  function random_neg_binomial (sk, p) result(ival) Arguments Type Intent Optional Attributes Name real, intent(in) :: sk real, intent(in) :: p Return Value integer public  function random_von_Mises (k, first) result(fn_val) Arguments Type Intent Optional Attributes Name real, intent(in) :: k logical, intent(in) :: first Return Value real public  function random_Cauchy () result(fn_val) Arguments None Return Value real Subroutines public  subroutine random_mvnorm (n, h, d, f, first, x, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: h (:) real, intent(in) :: d (:) real, intent(inout) :: f (:) logical, intent(in) :: first real, intent(out) :: x (:) integer, intent(out) :: ier public  subroutine random_order (order, n) Arguments Type Intent Optional Attributes Name integer, intent(out) :: order (n) integer, intent(in) :: n public  subroutine seed_random_number (iounit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iounit","tags":"","loc":"module/random.html"},{"title":"fffc_random – Fortran free function collection","text":"Uses fffc_kinds random Used by Descendants: fffc_random_randn fffc_random_randu Contents Interfaces randn randu Interfaces interface public impure elemental module subroutine randn(x, mean, std) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(out) :: x real(kind=fffc_real_kind), intent(in) :: mean real(kind=fffc_real_kind), intent(in) :: std interface public impure elemental module subroutine randu(x, min, max) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(out) :: x real(kind=fffc_real_kind), intent(in) :: min real(kind=fffc_real_kind), intent(in) :: max","tags":"","loc":"module/fffc_random.html"},{"title":"fffc_string – Fortran free function collection","text":"Uses fffc_kinds Used by Descendants: fffc_string_to_lower fffc_string_to_string fffc_string_to_upper Contents Interfaces to_string to_lower to_upper Interfaces public        interface to_string public module function to_string_real_kind(real, fmt) result(string) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: real character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable public module function to_string_int_kind(int, fmt) result(string) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: int character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable public module function to_string_logical_kind(logical, fmt) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logical character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable interface public pure module function to_lower(string) result(lower) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) interface public pure module function to_upper(string) result(upper) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len)","tags":"","loc":"module/fffc_string.html"},{"title":"fffc_linalg – Fortran free function collection","text":"Uses iso_fortran_env fffc_kinds Used by Descendants: fffc_linalg_det fffc_linalg_diag fffc_linalg_eye fffc_linalg_gemm fffc_linalg_inv fffc_linalg_inv_func fffc_linalg_linv fffc_linalg_rinv fffc_linalg_solve fffc_linalg_solve_func Contents Interfaces inv inv_func linv rinv solve solve_func diag gemm det eye Interfaces public        interface inv public module subroutine inv_real_kind(a) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a (:,:) public module subroutine inv_complex_kind(a) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(inout) :: a (:,:) public        interface inv_func public module function inv_func_real_kind(a) result(b) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) Return Value real(kind=fffc_real_kind), (size(a,1),size(a,2)) public module function inv_func_complex_kind(a) result(b) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(a,2)) public        interface linv m > n, 列满秩，使用 linv public module function linv_real_kind(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:,:) Return Value real(kind=fffc_real_kind), (size(x,2),size(x,1)) public module function linv_complex_kind(x) result(y) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: x (:,:) Return Value complex(kind=fffc_complex_kind), (size(x,2),size(x,1)) public        interface rinv m < n, 行满秩，使用 rinv public module function rinv_real_kind(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:,:) Return Value real(kind=fffc_real_kind), (size(x,2),size(x,1)) public module function rinv_complex_kind(x) result(y) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: x (:,:) Return Value complex(kind=fffc_complex_kind), (size(x,2),size(x,1)) public        interface solve public module subroutine solve_real_kind(a, b) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a (:,:) real(kind=fffc_real_kind), intent(inout) :: b (:,:) public module subroutine solve_complex_kind(a, b) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(inout) :: a (:,:) complex(kind=fffc_complex_kind), intent(inout) :: b (:,:) public        interface solve_func public module function solve_func_real_kind(a, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) real(kind=fffc_real_kind), intent(in) :: b (:,:) Return Value real(kind=fffc_real_kind), (size(b,1),size(b,2)) public module function solve_func_complex_kind(a, b) result(x) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) complex(kind=fffc_complex_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(b,1),size(b,2)) public        interface diag public pure module function diag_rank1(v) result(a) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: v (:) Return Value real(kind=fffc_real_kind), (size(v),size(v)) public pure module function diag_rank2(a) result(v) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) Return Value real(kind=fffc_real_kind), (min(size(a,1),size(a,2))) public        interface gemm public module function rrgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) real(kind=fffc_real_kind), intent(in) :: b (:,:) Return Value real(kind=fffc_real_kind), (size(a,1),size(b,2)) public module function ccgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) complex(kind=fffc_complex_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(b,2)) public module function crgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: a (:,:) real(kind=fffc_real_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(b,2)) public module function rcgemm(a, b) result(c) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a (:,:) complex(kind=fffc_complex_kind), intent(in) :: b (:,:) Return Value complex(kind=fffc_complex_kind), (size(a,1),size(b,2)) interface public module function det(a) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a (:,:) Return Value real(kind=fffc_real_kind) interface public pure module function eye(m, n) result(a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer(kind=int8), (m,n)","tags":"","loc":"module/fffc_linalg.html"},{"title":"fffc_filesystem – Fortran free function collection","text":"文件系统 Used by Descendants: fffc_filesystem_basename fffc_filesystem_countlines fffc_filesystem_dirname fffc_filesystem_exists fffc_filesystem_is_windows fffc_filesystem_join fffc_filesystem_mkdir fffc_filesystem_rmdir fffc_filesystem_unix_path Contents Interfaces is_windows exists countlines unix_path dirname basename mkdir rmdir operator(.join.) Interfaces interface public module function is_windows() Arguments None Return Value logical interface public module function exists(file, is_directory) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file logical, intent(in), optional :: is_directory Return Value logical interface public module function countlines(file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer interface public pure module function unix_path(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=len) interface public pure module function dirname(path) result(dir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:), allocatable interface public pure module function basename(path) result(base) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:), allocatable interface public module subroutine mkdir(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path interface public module subroutine rmdir(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path public        interface operator(.join.) public module function join(path, name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path character(len=*), intent(in) :: name Return Value character(len=len)","tags":"","loc":"module/fffc_filesystem.html"},{"title":"fffc_stats – Fortran free function collection","text":"Uses fffc_kinds Used by Descendants: fffc_stats_mean Contents Interfaces mean Interfaces public        interface mean public pure module function mean_real_kind(x) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:) Return Value real(kind=fffc_real_kind) public pure module function mean_int_kind(x) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: x (:) Return Value integer(kind=fffc_int_kind)","tags":"","loc":"module/fffc_stats.html"},{"title":"fffc_module – Fortran free function collection","text":"功能汇总 Uses fffc_filesystem fffc_random fffc_linalg fffc_constants random fffc_terminal fffc_stats fffc_time fffc_utils rkf45_module fffc_kinds fffc_math fffc_string Contents None","tags":"","loc":"module/fffc_module.html"},{"title":"fffc_constants – Fortran free function collection","text":"常数 Uses fffc_kinds Contents Variables pi g rad2deg deg2rad sqrt_eps Variables Type Visibility Attributes Name Initial real(kind=fffc_real_kind), public, parameter :: pi = acos(-1.0_fffc_real_kind) 圆周率 real(kind=fffc_real_kind), public, parameter :: g = 9.80665_fffc_real_kind 重力加速度, m/s&#94;2 real(kind=fffc_real_kind), public, parameter :: rad2deg = 180.0_fffc_real_kind/pi 弧度转角度 real(kind=fffc_real_kind), public, parameter :: deg2rad = pi/180.0_fffc_real_kind 角度转弧度 real(kind=fffc_real_kind), public, parameter :: sqrt_eps = sqrt(epsilon(1.0_fffc_real_kind)) 根号机器精度","tags":"","loc":"module/fffc_constants.html"},{"title":"fffc_utils – Fortran free function collection","text":"Uses fffc_kinds Used by Descendants: fffc_utils_bubble_sort fffc_utils_is_env fffc_utils_swap Contents Interfaces swap bubble_sort is_env Interfaces public        interface swap public elemental module subroutine swap_int_kind(a, b) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(inout) :: a integer(kind=fffc_int_kind), intent(inout) :: b public elemental module subroutine swap_real_kind(a, b) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: a real(kind=fffc_real_kind), intent(inout) :: b public        interface bubble_sort public pure module subroutine bubble_sort_real_kind(v) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(inout) :: v (:) public pure module subroutine bubble_sort_int_kind(v) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(inout) :: v (:) interface public module function is_env(key) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value logical","tags":"","loc":"module/fffc_utils.html"},{"title":"fffc_math – Fortran free function collection","text":"Uses fffc_kinds Used by Descendants: fffc_math_arange fffc_math_arg fffc_math_cross_product fffc_math_diff fffc_math_is_close fffc_math_linspace Contents Interfaces cross_product arange diff linspace arg is_close Interfaces public        interface cross_product public pure module function cross_product_real_kind(v1, v2) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: v1 (3) real(kind=fffc_real_kind), intent(in) :: v2 (3) Return Value real(kind=fffc_real_kind), (3) public pure module function cross_product_int_kind(v1, v2) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: v1 (3) integer(kind=fffc_int_kind), intent(in) :: v2 (3) Return Value integer(kind=fffc_int_kind), (3) public        interface arange public pure module function arange_real_kind(start, stop, step) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: start real(kind=fffc_real_kind), intent(in) :: stop real(kind=fffc_real_kind), intent(in), optional :: step Return Value real(kind=fffc_real_kind), allocatable, (:) public pure module function arange_int_kind(start, stop, step) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: start integer(kind=fffc_int_kind), intent(in) :: stop integer(kind=fffc_int_kind), intent(in), optional :: step Return Value integer(kind=fffc_int_kind), allocatable, (:) public        interface diff public pure module function diff_real_kind(x, n, prepend, append) result(y) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: x (:) integer, intent(in), optional :: n real(kind=fffc_real_kind), intent(in), optional :: prepend (:) real(kind=fffc_real_kind), intent(in), optional :: append (:) Return Value real(kind=fffc_real_kind), allocatable, (:) public pure module function diff_int_kind(x, n, prepend, append) result(y) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: x (:) integer, intent(in), optional :: n integer(kind=fffc_int_kind), intent(in), optional :: prepend (:) integer(kind=fffc_int_kind), intent(in), optional :: append (:) Return Value integer(kind=fffc_int_kind), allocatable, (:) public        interface linspace public pure module function linspace_real_kind(start, stop, n) result(ans) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: start real(kind=fffc_real_kind), intent(in) :: stop integer, intent(in) :: n Return Value real(kind=fffc_real_kind), (max(0,n)) public pure module function linspace_int_kind(start, stop, n) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=fffc_int_kind), intent(in) :: start integer(kind=fffc_int_kind), intent(in) :: stop integer, intent(in) :: n Return Value integer(kind=fffc_int_kind), (max(0,n)) interface public elemental module function arg(z) Arguments Type Intent Optional Attributes Name complex(kind=fffc_complex_kind), intent(in) :: z Return Value real(kind=fffc_real_kind) interface public elemental module function is_close(a, b, rel_tol, abs_tol, equal_nan) result(close) Arguments Type Intent Optional Attributes Name real(kind=fffc_real_kind), intent(in) :: a real(kind=fffc_real_kind), intent(in) :: b real(kind=fffc_real_kind), intent(in), optional :: rel_tol real(kind=fffc_real_kind), intent(in), optional :: abs_tol logical, intent(in), optional :: equal_nan Return Value logical","tags":"","loc":"module/fffc_math.html"},{"title":"fffc_time – Fortran free function collection","text":"Uses fffc_kinds Contents Derived Types timer Functions toc nowtime Subroutines tic Derived Types type, public :: timer Type-Bound Procedures procedure\n                    ,                  public\n,                   :: nowtime Function procedure\n                    ,                  public\n,                   :: toc Function procedure\n                    ,                  public\n,                   :: tic Subroutine Functions public  function toc (self) Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: self Return Value real(kind=fffc_real_kind) public  function nowtime (self) result(t) Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: self Return Value character(len=23) Subroutines public  subroutine tic (self) Arguments Type Intent Optional Attributes Name class( timer ), intent(out) :: self","tags":"","loc":"module/fffc_time.html"},{"title":"fffc_terminal – Fortran free function collection","text":"终端 Uses fffc_utils iso_c_binding Contents Variables terminal_obj Derived Types terminal Variables Type Visibility Attributes Name Initial type( terminal ), public :: terminal_obj Derived Types type, public :: terminal Type-Bound Procedures procedure\n                    ,                  public\n,                   :: setup =>\n                    set_terminal Subroutine procedure\n                    ,                  public\n,                   :: progress_bar =>\n                    terminal_progress_bar Subroutine procedure\n                    ,                  public\n,                   :: info =>\n                    terminal_info Subroutine procedure\n                    ,                  public\n,                   :: warning =>\n                    terminal_warning Subroutine procedure\n                    ,                  public\n,                   :: error =>\n                    terminal_error Subroutine procedure\n                    ,                  public\n,                   :: success =>\n                    terminal_success Subroutine procedure\n                    ,                  public\n,                   :: red Function procedure\n                    ,                  public\n,                   :: yellow Function procedure\n                    ,                  public\n,                   :: green Function procedure\n                    ,                  public\n,                   :: blue Function","tags":"","loc":"module/fffc_terminal.html"},{"title":"fffc_kinds – Fortran free function collection","text":"Contents Variables fffc_real_kind fffc_real_kind fffc_complex_kind fffc_int_kind Variables Type Visibility Attributes Name Initial integer, public, parameter :: fffc_real_kind = kind(0.0d0) integer, public, parameter :: fffc_real_kind = kind(0.0) integer, public, parameter :: fffc_complex_kind = fffc_real_kind integer, public, parameter :: fffc_int_kind = kind(0)","tags":"","loc":"module/fffc_kinds.html"},{"title":"rkf45_module – Fortran free function collection","text":"Uses fffc_kinds Contents Subroutines rkf45 Subroutines public  subroutine rkf45 (f, neqn, y, t, tout, relerr, abserr, iflag, work, iwork) rkf45 is primarily designed to solve non-stiff and mildly stiff\ndifferential equations when derivative evaluations are inexpensive.\nrkf45 should generally not be used when the user is demanding\nhigh accuracy.\n在计算量不大的计算中，rkf45主要用于求解非刚性和轻微刚性的常微分方程。 Arguments Type Intent Optional Attributes Name procedure(fcn) :: f integer, intent(in) :: neqn real(kind=rk), intent(inout) :: y (neqn) real(kind=rk), intent(inout) :: t real(kind=rk), intent(in) :: tout real(kind=rk), intent(inout) :: relerr real(kind=rk), intent(in) :: abserr integer, intent(inout) :: iflag real(kind=rk), intent(inout) :: work (*) integer, intent(inout) :: iwork (5)","tags":"","loc":"module/rkf45_module.html"},{"title":"fffc_linalg_rinv – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_rinv.html"},{"title":"fffc_filesystem_is_windows – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_is_windows.html"},{"title":"fffc_random_randn – Fortran free function collection","text":"Uses Ancestors: fffc_random Contents None","tags":"","loc":"module/fffc_random_randn.html"},{"title":"fffc_linalg_linv – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_linv.html"},{"title":"fffc_linalg_inv_func – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_inv_func.html"},{"title":"fffc_random_randu – Fortran free function collection","text":"Uses Ancestors: fffc_random Contents None","tags":"","loc":"module/fffc_random_randu.html"},{"title":"fffc_filesystem_join – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_join.html"},{"title":"fffc_math_linspace – Fortran free function collection","text":"Uses Ancestors: fffc_math Contents None","tags":"","loc":"module/fffc_math_linspace.html"},{"title":"fffc_math_cross_product – Fortran free function collection","text":"Uses Ancestors: fffc_math Contents None","tags":"","loc":"module/fffc_math_cross_product.html"},{"title":"fffc_utils_is_env – Fortran free function collection","text":"Uses Ancestors: fffc_utils Contents None","tags":"","loc":"module/fffc_utils_is_env.html"},{"title":"fffc_filesystem_rmdir – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_rmdir.html"},{"title":"fffc_linalg_eye – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_eye.html"},{"title":"fffc_filesystem_dirname – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_dirname.html"},{"title":"fffc_utils_bubble_sort – Fortran free function collection","text":"Uses Ancestors: fffc_utils Contents None","tags":"","loc":"module/fffc_utils_bubble_sort.html"},{"title":"fffc_filesystem_mkdir – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_mkdir.html"},{"title":"fffc_filesystem_exists – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_exists.html"},{"title":"fffc_linalg_solve – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_solve.html"},{"title":"fffc_string_to_lower – Fortran free function collection","text":"Uses Ancestors: fffc_string Contents None","tags":"","loc":"module/fffc_string_to_lower.html"},{"title":"fffc_utils_swap – Fortran free function collection","text":"Uses Ancestors: fffc_utils Contents None","tags":"","loc":"module/fffc_utils_swap.html"},{"title":"fffc_linalg_solve_func – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_solve_func.html"},{"title":"fffc_math_arg – Fortran free function collection","text":"Uses Ancestors: fffc_math Contents None","tags":"","loc":"module/fffc_math_arg.html"},{"title":"fffc_math_diff – Fortran free function collection","text":"Uses Ancestors: fffc_math Contents None","tags":"","loc":"module/fffc_math_diff.html"},{"title":"fffc_filesystem_basename – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_basename.html"},{"title":"fffc_math_is_close – Fortran free function collection","text":"Uses ieee_arithmetic Ancestors: fffc_math Contents None","tags":"","loc":"module/fffc_math_is_close.html"},{"title":"fffc_stats_mean – Fortran free function collection","text":"Uses Ancestors: fffc_stats Contents None","tags":"","loc":"module/fffc_stats_mean.html"},{"title":"fffc_linalg_inv – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_inv.html"},{"title":"fffc_linalg_gemm – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_gemm.html"},{"title":"fffc_linalg_diag – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_diag.html"},{"title":"fffc_filesystem_countlines – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_countlines.html"},{"title":"fffc_filesystem_unix_path – Fortran free function collection","text":"Uses Ancestors: fffc_filesystem Contents None","tags":"","loc":"module/fffc_filesystem_unix_path.html"},{"title":"fffc_string_to_upper – Fortran free function collection","text":"Uses Ancestors: fffc_string Contents None","tags":"","loc":"module/fffc_string_to_upper.html"},{"title":"fffc_math_arange – Fortran free function collection","text":"Uses Ancestors: fffc_math Contents None","tags":"","loc":"module/fffc_math_arange.html"},{"title":"fffc_linalg_det – Fortran free function collection","text":"Uses Ancestors: fffc_linalg Contents None","tags":"","loc":"module/fffc_linalg_det.html"},{"title":"fffc_string_to_string – Fortran free function collection","text":"Uses Ancestors: fffc_string Contents None","tags":"","loc":"module/fffc_string_to_string.html"},{"title":"random.f90 – Fortran free function collection","text":"Contents Modules random Source Code random.f90 Source Code MODULE random ! A module for random number generation from the following distributions: ! !     Distribution                    Function/subroutine name ! !     Normal (Gaussian)               random_normal !     Gamma                           random_gamma !     Chi-squared                     random_chisq !     Exponential                     random_exponential !     Weibull                         random_Weibull !     Beta                            random_beta !     t                               random_t !     Multivariate normal             random_mvnorm !     Generalized inverse Gaussian    random_inv_gauss !     Poisson                         random_Poisson !     Binomial                        random_binomial1   * !                                     random_binomial2   * !     Negative binomial               random_neg_binomial !     von Mises                       random_von_Mises !     Cauchy                          random_Cauchy ! !  Generate a random ordering of the integers 1 .. N !                                     random_order !     Initialize (seed) the uniform random number generator for ANY compiler !                                     seed_random_number !     Lognormal - see note below. !  ** Two functions are provided for the binomial distribution. !  If the parameter values remain constant, it is recommended that the !  first function is used (random_binomial1).   If one or both of the !  parameters change, use the second function (random_binomial2). ! The compilers own random number generator, SUBROUTINE RANDOM_NUMBER(r), ! is used to provide a source of uniformly distributed random numbers. ! N.B. At this stage, only one random number is generated at each call to !      one of the functions above. ! The module uses the following functions which are included here: ! bin_prob to calculate a single binomial probability ! lngamma  to calculate the logarithm to base e of the gamma function ! Some of the code is adapted from Dagpunar's book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! ! In most of Dagpunar's routines, there is a test to see whether the value ! of one or two floating-point parameters has changed since the last call. ! These tests have been replaced by using a logical variable FIRST. ! This should be set to .TRUE. on the first call using new values of the ! parameters, and .FALSE. if the parameter values are the same as for the ! previous call. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Lognormal distribution ! If X has a lognormal distribution, then log(X) is normally distributed. ! Here the logarithm is the natural logarithm, that is to base e, sometimes ! denoted as ln.  To generate random variates from this distribution, generate ! a random deviate from the normal distribution with mean and variance equal ! to the mean and variance of the logarithms of X, then take its exponential. ! Relationship between the mean & variance of log(X) and the mean & variance ! of X, when X has a lognormal distribution. ! Let m = mean of log(X), and s&#94;2 = variance of log(X) ! Then ! mean of X     = exp(m + 0.5s&#94;2) ! variance of X = (mean(X))&#94;2.[exp(s&#94;2) - 1] ! In the reverse direction (rarely used) ! variance of log(X) = log[1 + var(X)/(mean(X))&#94;2] ! mean of log(X)     = log(mean(X) - 0.5var(log(X)) ! N.B. The above formulae relate to population parameters; they will only be !      approximate if applied to sample values. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Version 1.13, 2 October 2000 ! Changes from version 1.01 ! 1. The random_order, random_Poisson & random_binomial routines have been !    replaced with more efficient routines. ! 2. A routine, seed_random_number, has been added to seed the uniform random !    number generator.   This requires input of the required number of seeds !    for the particular compiler from a specified I/O unit such as a keyboard. ! 3. Made compatible with Lahey's ELF90. ! 4. Marsaglia & Tsang algorithm used for random_gamma when shape parameter > 1. ! 5. INTENT for array f corrected in random_mvnorm. !     Author: Alan Miller !             CSIRO Division of Mathematical & Information Sciences !             Private Bag 10, Clayton South MDC !             Clayton 3169, Victoria, Australia !     Phone: (+61) 3 9545-8016      Fax: (+61) 3 9545-8080 !     e-mail: amiller @ bigpond.net.au USE fffc_kinds IMPLICIT NONE REAL , PRIVATE :: zero = 0.0 , half = 0.5 , one = 1.0 , two = 2.0 , & vsmall = TINY ( 1.0 ), vlarge = HUGE ( 1.0 ) PRIVATE :: integral INTEGER , PARAMETER :: dp = SELECTED_REAL_KIND ( 12 , 60 ) CONTAINS FUNCTION random_normal () RESULT ( fn_val ) ! Adapted from the following Fortran 77 code !      ALGORITHM 712, COLLECTED ALGORITHMS FROM ACM. !      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE, !      VOL. 18, NO. 4, DECEMBER, 1992, PP. 434-435. !  The function random_normal() returns a normally distributed pseudo-random !  number with zero mean and unit variance. !  The algorithm uses the ratio of uniforms method of A.J. Kinderman !  and J.F. Monahan augmented with quadratic bounding curves. REAL :: fn_val !     Local variables REAL :: s = 0.449871 , t = - 0.386595 , a = 0.19600 , b = 0.25472 , & r1 = 0.27597 , r2 = 0.27846 , u , v , x , y , q !     Generate P = (u,v) uniform in rectangle enclosing acceptance region DO CALL RANDOM_NUMBER ( u ) CALL RANDOM_NUMBER ( v ) v = 1.7156 * ( v - half ) !     Evaluate the quadratic form x = u - s y = ABS ( v ) - t q = x ** 2 + y * ( a * y - b * x ) !     Accept P if inside inner ellipse IF ( q < r1 ) EXIT !     Reject P if outside outer ellipse IF ( q > r2 ) CYCLE !     Reject P if outside acceptance region IF ( v ** 2 < - 4.0 * LOG ( u ) * u ** 2 ) EXIT END DO !     Return ratio of P's coordinates as the normal deviate fn_val = v / u RETURN END FUNCTION random_normal FUNCTION random_gamma ( s , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 !     FUNCTION GENERATES A RANDOM GAMMA VARIATE. !     CALLS EITHER random_gamma1 (S > 1.0) !     OR random_exponential (S = 1.0) !     OR random_gamma2 (S < 1.0). !     S = SHAPE PARAMETER OF DISTRIBUTION (0 < REAL). REAL , INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first REAL :: fn_val IF ( s <= zero ) THEN WRITE ( * , * ) 'SHAPE PARAMETER VALUE MUST BE POSITIVE' STOP END IF IF ( s > one ) THEN fn_val = random_gamma1 ( s , first ) ELSE IF ( s < one ) THEN fn_val = random_gamma2 ( s , first ) ELSE fn_val = random_exponential () END IF RETURN END FUNCTION random_gamma FUNCTION random_gamma1 ( s , first ) RESULT ( fn_val ) ! Uses the algorithm in ! Marsaglia, G. and Tsang, W.W. (2000) `A simple method for generating ! gamma variables', Trans. om Math. Software (TOMS), vol.26(3), pp.363-372. ! Generates a random gamma deviate for shape parameter s >= 1. REAL , INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first REAL :: fn_val ! Local variables REAL , SAVE :: c , d REAL :: u , v , x IF ( first ) THEN d = s - one / 3. c = one / SQRT ( 9.0 * d ) END IF ! Start of main loop DO ! Generate v = (1+cx)&#94;3 where x is random normal; repeat if v <= 0. DO x = random_normal () v = ( one + c * x ) ** 3 IF ( v > zero ) EXIT END DO ! Generate uniform variable U CALL RANDOM_NUMBER ( u ) IF ( u < one - 0.0331 * x ** 4 ) THEN fn_val = d * v EXIT ELSE IF ( LOG ( u ) < half * x ** 2 + d * ( one - v + LOG ( v ))) THEN fn_val = d * v EXIT END IF END DO RETURN END FUNCTION random_gamma1 FUNCTION random_gamma2 ( s , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM ! A GAMMA DISTRIBUTION WITH DENSITY PROPORTIONAL TO ! GAMMA2**(S-1) * EXP(-GAMMA2), ! USING A SWITCHING METHOD. !    S = SHAPE PARAMETER OF DISTRIBUTION !          (REAL < 1.0) REAL , INTENT ( IN ) :: s LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables REAL :: r , x , w REAL , SAVE :: a , p , c , uf , vr , d IF ( s <= zero . OR . s >= one ) THEN WRITE ( * , * ) 'SHAPE PARAMETER VALUE OUTSIDE PERMITTED RANGE' STOP END IF IF ( first ) THEN ! Initialization, if necessary a = one - s p = a / ( a + s * EXP ( - a )) IF ( s < vsmall ) THEN WRITE ( * , * ) 'SHAPE PARAMETER VALUE TOO SMALL' STOP END IF c = one / s uf = p * ( vsmall / a ) ** s vr = one - vsmall d = a * LOG ( a ) END IF DO CALL RANDOM_NUMBER ( r ) IF ( r >= vr ) THEN CYCLE ELSE IF ( r > p ) THEN x = a - LOG (( one - r ) / ( one - p )) w = a * LOG ( x ) - d ELSE IF ( r > uf ) THEN x = a * ( r / p ) ** c w = x ELSE fn_val = zero RETURN END IF CALL RANDOM_NUMBER ( r ) IF ( one - r <= w . AND . r > zero ) THEN IF ( r * ( w + one ) >= one ) CYCLE IF ( - LOG ( r ) <= w ) CYCLE END IF EXIT END DO fn_val = x RETURN END FUNCTION random_gamma2 FUNCTION random_chisq ( ndf , first ) RESULT ( fn_val ) !     Generates a random variate from the chi-squared distribution with !     ndf degrees of freedom INTEGER , INTENT ( IN ) :: ndf LOGICAL , INTENT ( IN ) :: first REAL :: fn_val fn_val = two * random_gamma ( half * ndf , first ) RETURN END FUNCTION random_chisq FUNCTION random_exponential () RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY) FROM ! A NEGATIVE EXPONENTIAL DlSTRIBUTION WlTH DENSITY PROPORTIONAL ! TO EXP(-random_exponential), USING INVERSION. REAL :: fn_val !     Local variable REAL :: r DO CALL RANDOM_NUMBER ( r ) IF ( r > zero ) EXIT END DO fn_val = - LOG ( r ) RETURN END FUNCTION random_exponential FUNCTION random_Weibull ( a ) RESULT ( fn_val ) !     Generates a random variate from the Weibull distribution with !     probability density: !                      a !               a-1  -x !     f(x) = a.x    e REAL , INTENT ( IN ) :: a REAL :: fn_val !     For speed, there is no checking that a is not zero or very small. fn_val = random_exponential () ** ( one / a ) RETURN END FUNCTION random_Weibull FUNCTION random_beta ( aa , bb , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,1] ! FROM A BETA DISTRIBUTION WITH DENSITY ! PROPORTIONAL TO BETA**(AA-1) * (1-BETA)**(BB-1). ! USING CHENG'S LOG LOGISTIC METHOD. !     AA = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) !     BB = SHAPE PARAMETER FROM DISTRIBUTION (0 < REAL) REAL , INTENT ( IN ) :: aa , bb LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables REAL , PARAMETER :: aln4 = 1.3862944 REAL :: a , b , g , r , s , x , y , z REAL , SAVE :: d , f , h , t , c LOGICAL , SAVE :: swap IF ( aa <= zero . OR . bb <= zero ) THEN WRITE ( * , * ) 'IMPERMISSIBLE SHAPE PARAMETER VALUE(S)' STOP END IF IF ( first ) THEN ! Initialization, if necessary a = aa b = bb swap = b > a IF ( swap ) THEN g = b b = a a = g END IF d = a / b f = a + b IF ( b > one ) THEN h = SQRT (( two * a * b - f ) / ( f - two )) t = one ELSE h = b t = one / ( one + ( a / ( vlarge * b )) ** b ) END IF c = a + h END IF DO CALL RANDOM_NUMBER ( r ) CALL RANDOM_NUMBER ( x ) s = r * r * x IF ( r < vsmall . OR . s <= zero ) CYCLE IF ( r < t ) THEN x = LOG ( r / ( one - r )) / h y = d * EXP ( x ) z = c * x + f * LOG (( one + d ) / ( one + y )) - aln4 IF ( s - one > z ) THEN IF ( s - s * z > one ) CYCLE IF ( LOG ( s ) > z ) CYCLE END IF fn_val = y / ( one + y ) ELSE IF ( 4.0 * s > ( one + one / d ) ** f ) CYCLE fn_val = one END IF EXIT END DO IF ( swap ) fn_val = one - fn_val RETURN END FUNCTION random_beta FUNCTION random_t ( m ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE FROM A ! T DISTRIBUTION USING KINDERMAN AND MONAHAN'S RATIO METHOD. !     M = DEGREES OF FREEDOM OF DISTRIBUTION !           (1 <= 1NTEGER) INTEGER , INTENT ( IN ) :: m REAL :: fn_val !     Local variables REAL , SAVE :: s , c , a , f , g REAL :: r , x , v REAL , PARAMETER :: three = 3.0 , four = 4.0 , quart = 0.25 , & five = 5.0 , sixteen = 1 6.0 INTEGER :: mm = 0 IF ( m < 1 ) THEN WRITE ( * , * ) 'IMPERMISSIBLE DEGREES OF FREEDOM' STOP END IF IF ( m /= mm ) THEN ! Initialization, if necessary s = m c = - quart * ( s + one ) a = four / ( one + one / s ) ** c f = sixteen / a IF ( m > 1 ) THEN g = s - one g = (( s + one ) / g ) ** c * SQRT (( s + s ) / g ) ELSE g = one END IF mm = m END IF DO CALL RANDOM_NUMBER ( r ) IF ( r <= zero ) CYCLE CALL RANDOM_NUMBER ( v ) x = ( two * v - one ) * g / r v = x * x IF ( v > five - a * r ) THEN IF ( m >= 1 . AND . r * ( v + three ) > f ) CYCLE IF ( r > ( one + v / s ) ** c ) CYCLE END IF EXIT END DO fn_val = x RETURN END FUNCTION random_t SUBROUTINE random_mvnorm ( n , h , d , f , first , x , ier ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! N.B. An extra argument, ier, has been added to Dagpunar's routine !     SUBROUTINE GENERATES AN N VARIATE RANDOM NORMAL !     VECTOR USING A CHOLESKY DECOMPOSITION. ! ARGUMENTS: !        N = NUMBER OF VARIATES IN VECTOR !           (INPUT,INTEGER >= 1) !     H(J) = J'TH ELEMENT OF VECTOR OF MEANS !           (INPUT,REAL) !     X(J) = J'TH ELEMENT OF DELIVERED VECTOR !           (OUTPUT,REAL) ! !    D(J*(J-1)/2+I) = (I,J)'TH ELEMENT OF VARIANCE MATRIX (J> = I) !            (INPUT,REAL) !    F((J-1)*(2*N-J)/2+I) = (I,J)'TH ELEMENT OF LOWER TRIANGULAR !           DECOMPOSITION OF VARIANCE MATRIX (J <= I) !            (OUTPUT,REAL) !    FIRST = .TRUE. IF THIS IS THE FIRST CALL OF THE ROUTINE !    OR IF THE DISTRIBUTION HAS CHANGED SINCE THE LAST CALL OF THE ROUTINE. !    OTHERWISE SET TO .FALSE. !            (INPUT,LOGICAL) !    ier = 1 if the input covariance matrix is not +ve definite !        = 0 otherwise INTEGER , INTENT ( IN ) :: n REAL , INTENT ( IN ) :: h (:), d (:) ! d(n*(n+1)/2) REAL , INTENT ( IN OUT ) :: f (:) ! f(n*(n+1)/2) REAL , INTENT ( OUT ) :: x (:) LOGICAL , INTENT ( IN ) :: first INTEGER , INTENT ( OUT ) :: ier !     Local variables INTEGER :: j , i , m REAL :: y , v INTEGER , SAVE :: n2 IF ( n < 1 ) THEN WRITE ( * , * ) 'SIZE OF VECTOR IS NON POSITIVE' STOP END IF ier = 0 IF ( first ) THEN ! Initialization, if necessary n2 = 2 * n IF ( d ( 1 ) < zero ) THEN ier = 1 RETURN END IF f ( 1 ) = SQRT ( d ( 1 )) y = one / f ( 1 ) DO j = 2 , n f ( j ) = d ( 1 + j * ( j - 1 ) / 2 ) * y END DO DO i = 2 , n v = d ( i * ( i - 1 ) / 2 + i ) DO m = 1 , i - 1 v = v - f (( m - 1 ) * ( n2 - m ) / 2 + i ) ** 2 END DO IF ( v < zero ) THEN ier = 1 RETURN END IF v = SQRT ( v ) y = one / v f (( i - 1 ) * ( n2 - i ) / 2 + i ) = v DO j = i + 1 , n v = d ( j * ( j - 1 ) / 2 + i ) DO m = 1 , i - 1 v = v - f (( m - 1 ) * ( n2 - m ) / 2 + i ) * f (( m - 1 ) * ( n2 - m ) / 2 + j ) END DO ! m = 1,i-1 f (( i - 1 ) * ( n2 - i ) / 2 + j ) = v * y END DO ! j = i+1,n END DO ! i = 2,n END IF x ( 1 : n ) = h ( 1 : n ) DO j = 1 , n y = random_normal () DO i = j , n x ( i ) = x ( i ) + f (( j - 1 ) * ( n2 - j ) / 2 + i ) * y END DO ! i = j,n END DO ! j = 1,n RETURN END SUBROUTINE random_mvnorm FUNCTION random_inv_gauss ( h , b , first ) RESULT ( fn_val ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM VARIATE IN [0,INFINITY] FROM ! A REPARAMETERISED GENERALISED INVERSE GAUSSIAN (GIG) DISTRIBUTION ! WITH DENSITY PROPORTIONAL TO  GIG**(H-1) * EXP(-0.5*B*(GIG+1/GIG)) ! USING A RATIO METHOD. !     H = PARAMETER OF DISTRIBUTION (0 <= REAL) !     B = PARAMETER OF DISTRIBUTION (0 < REAL) REAL , INTENT ( IN ) :: h , b LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables REAL :: ym , xm , r , w , r1 , r2 , x REAL , SAVE :: a , c , d , e REAL , PARAMETER :: quart = 0.25 IF ( h < zero . OR . b <= zero ) THEN WRITE ( * , * ) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' STOP END IF IF ( first ) THEN ! Initialization, if necessary IF ( h > quart * b * SQRT ( vlarge )) THEN WRITE ( * , * ) 'THE RATIO H:B IS TOO SMALL' STOP END IF e = b * b d = h + one ym = ( - d + SQRT ( d * d + e )) / b IF ( ym < vsmall ) THEN WRITE ( * , * ) 'THE VALUE OF B IS TOO SMALL' STOP END IF d = h - one xm = ( d + SQRT ( d * d + e )) / b d = half * d e = - quart * b r = xm + one / xm w = xm * ym a = w ** ( - half * h ) * SQRT ( xm / ym ) * EXP ( - e * ( r - ym - one / ym )) IF ( a < vsmall ) THEN WRITE ( * , * ) 'THE VALUE OF H IS TOO LARGE' STOP END IF c = - d * LOG ( xm ) - e * r END IF DO CALL RANDOM_NUMBER ( r1 ) IF ( r1 <= zero ) CYCLE CALL RANDOM_NUMBER ( r2 ) x = a * r2 / r1 IF ( x <= zero ) CYCLE IF ( LOG ( r1 ) < d * LOG ( x ) + e * ( x + one / x ) + c ) EXIT END DO fn_val = x RETURN END FUNCTION random_inv_gauss FUNCTION random_Poisson ( mu , first ) RESULT ( ival ) !********************************************************************** !     Translated to Fortran 90 by Alan Miller from: !                           RANLIB ! !     Library of Fortran Routines for Random Number Generation ! !                    Compiled and Written by: ! !                         Barry W. Brown !                          James Lovato ! !             Department of Biomathematics, Box 237 !             The University of Texas, M.D. Anderson Cancer Center !             1515 Holcombe Boulevard !             Houston, TX      77030 ! ! This work was supported by grant CA-16672 from the National Cancer Institute. !                    GENerate POIsson random deviate !                            Function ! Generates a single random deviate from a Poisson distribution with mean mu. !                            Arguments !     mu --> The mean of the Poisson distribution from which !            a random deviate is to be generated. !                              REAL mu !                              Method !     For details see: !               Ahrens, J.H. and Dieter, U. !               Computer Generation of Poisson Deviates !               From Modified Normal Distributions. !               ACM Trans. Math. Software, 8, 2 !               (June 1982),163-179 !     TABLES: COEFFICIENTS A0-A7 FOR STEP F. FACTORIALS FACT !     COEFFICIENTS A(K) - FOR PX = FK*V*V*SUM(A(K)*V**K)-DEL !     SEPARATION OF CASES A AND B !     .. Scalar Arguments .. REAL , INTENT ( IN ) :: mu LOGICAL , INTENT ( IN ) :: first INTEGER :: ival !     .. !     .. Local Scalars .. REAL :: b1 , b2 , c , c0 , c1 , c2 , c3 , del , difmuk , e , fk , fx , fy , g , & omega , px , py , t , u , v , x , xx REAL , SAVE :: s , d , p , q , p0 INTEGER :: j , k , kflag LOGICAL , SAVE :: full_init INTEGER , SAVE :: l , m !     .. !     .. Local Arrays .. REAL , SAVE :: pp ( 35 ) !     .. !     .. Data statements .. REAL , PARAMETER :: a0 = - . 5 , a1 = . 3333333 , a2 = - . 2500068 , a3 = . 2000118 , & a4 = - . 1661269 , a5 = . 1421878 , a6 = - . 1384794 , & a7 = . 1250060 REAL , PARAMETER :: fact ( 10 ) = ( / 1. , 1. , 2. , 6. , 2 4. , 12 0. , 72 0. , 504 0. , & 4032 0. , 36288 0. / ) !     .. !     .. Executable Statements .. IF ( mu > 1 0.0 ) THEN !     C A S E  A. (RECALCULATION OF S, D, L IF MU HAS CHANGED) IF ( first ) THEN s = SQRT ( mu ) d = 6.0 * mu * mu !             THE POISSON PROBABILITIES PK EXCEED THE DISCRETE NORMAL !             PROBABILITIES FK WHENEVER K >= M(MU). L=IFIX(MU-1.1484) !             IS AN UPPER BOUND TO M(MU) FOR ALL MU >= 10 . l = mu - 1.1484 full_init = . false . END IF !     STEP N. NORMAL SAMPLE - random_normal() FOR STANDARD NORMAL DEVIATE g = mu + s * random_normal () IF ( g > 0.0 ) THEN ival = g !     STEP I. IMMEDIATE ACCEPTANCE IF ival IS LARGE ENOUGH IF ( ival >= l ) RETURN !     STEP S. SQUEEZE ACCEPTANCE - SAMPLE U fk = ival difmuk = mu - fk CALL RANDOM_NUMBER ( u ) IF ( d * u >= difmuk * difmuk * difmuk ) RETURN END IF !     STEP P. PREPARATIONS FOR STEPS Q AND H. !             (RECALCULATIONS OF PARAMETERS IF NECESSARY) !             .3989423=(2*PI)**(-.5)  .416667E-1=1./24.  .1428571=1./7. !             THE QUANTITIES B1, B2, C3, C2, C1, C0 ARE FOR THE HERMITE !             APPROXIMATIONS TO THE DISCRETE NORMAL PROBABILITIES FK. !             C=.1069/MU GUARANTEES MAJORIZATION BY THE 'HAT'-FUNCTION. IF (. NOT . full_init ) THEN omega = . 3989423 / s b1 = . 416666 7E-1 / mu b2 = . 3 * b1 * b1 c3 = . 1428571 * b1 * b2 c2 = b2 - 1 5. * c3 c1 = b1 - 6. * b2 + 4 5. * c3 c0 = 1. - b1 + 3. * b2 - 1 5. * c3 c = . 1069 / mu full_init = . true . END IF IF ( g < 0.0 ) GO TO 50 !             'SUBROUTINE' F IS CALLED (KFLAG=0 FOR CORRECT RETURN) kflag = 0 GO TO 70 !     STEP Q. QUOTIENT ACCEPTANCE (RARE CASE) 40 IF ( fy - u * fy <= py * EXP ( px - fx )) RETURN !     STEP E. EXPONENTIAL SAMPLE - random_exponential() FOR STANDARD EXPONENTIAL !             DEVIATE E AND SAMPLE T FROM THE LAPLACE 'HAT' !             (IF T <= -.6744 THEN PK < FK FOR ALL MU >= 10.) 50 e = random_exponential () CALL RANDOM_NUMBER ( u ) u = u + u - one t = 1.8 + SIGN ( e , u ) IF ( t <= ( - . 6744 )) GO TO 50 ival = mu + s * t fk = ival difmuk = mu - fk !             'SUBROUTINE' F IS CALLED (KFLAG=1 FOR CORRECT RETURN) kflag = 1 GO TO 70 !     STEP H. HAT ACCEPTANCE (E IS REPEATED ON REJECTION) 60 IF ( c * ABS ( u ) > py * EXP ( px + e ) - fy * EXP ( fx + e )) GO TO 50 RETURN !     STEP F. 'SUBROUTINE' F. CALCULATION OF PX, PY, FX, FY. !             CASE ival < 10 USES FACTORIALS FROM TABLE FACT 70 IF ( ival >= 10 ) GO TO 80 px = - mu py = mu ** ival / fact ( ival + 1 ) GO TO 110 !             CASE ival >= 10 USES POLYNOMIAL APPROXIMATION !             A0-A7 FOR ACCURACY WHEN ADVISABLE !             .8333333E-1=1./12.  .3989423=(2*PI)**(-.5) 80 del = . 833333 3E-1 / fk del = del - 4.8 * del * del * del v = difmuk / fk IF ( ABS ( v ) > 0.25 ) THEN px = fk * LOG ( one + v ) - difmuk - del ELSE px = fk * v * v * ((((((( a7 * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v + a0 ) - del END IF py = . 3989423 / SQRT ( fk ) 110 x = ( half - difmuk ) / s xx = x * x fx = - half * xx fy = omega * ((( c3 * xx + c2 ) * xx + c1 ) * xx + c0 ) IF ( kflag <= 0 ) GO TO 40 GO TO 60 !--------------------------------------------------------------------------- !     C A S E  B.    mu < 10 !     START NEW TABLE AND CALCULATE P0 IF NECESSARY ELSE IF ( first ) THEN m = MAX ( 1 , INT ( mu )) l = 0 p = EXP ( - mu ) q = p p0 = p END IF !     STEP U. UNIFORM SAMPLE FOR INVERSION METHOD DO CALL RANDOM_NUMBER ( u ) ival = 0 IF ( u <= p0 ) RETURN !     STEP T. TABLE COMPARISON UNTIL THE END PP(L) OF THE !             PP-TABLE OF CUMULATIVE POISSON PROBABILITIES !             (0.458=PP(9) FOR MU=10) IF ( l == 0 ) GO TO 150 j = 1 IF ( u > 0.458 ) j = MIN ( l , m ) DO k = j , l IF ( u <= pp ( k )) GO TO 180 END DO IF ( l == 35 ) CYCLE !     STEP C. CREATION OF NEW POISSON PROBABILITIES P !             AND THEIR CUMULATIVES Q=PP(K) 150 l = l + 1 DO k = l , 35 p = p * mu / k q = q + p pp ( k ) = q IF ( u <= q ) GO TO 170 END DO l = 35 END DO 170 l = k 180 ival = k RETURN END IF RETURN END FUNCTION random_Poisson FUNCTION random_binomial1 ( n , p , first ) RESULT ( ival ) ! FUNCTION GENERATES A RANDOM BINOMIAL VARIATE USING C.D.Kemp's method. ! This algorithm is suitable when many random variates are required ! with the SAME parameter values for n & p. !    P = BERNOULLI SUCCESS PROBABILITY !           (0 <= REAL <= 1) !    N = NUMBER OF BERNOULLI TRIALS !           (1 <= INTEGER) !    FIRST = .TRUE. for the first call using the current parameter values !          = .FALSE. if the values of (n,p) are unchanged from last call ! Reference: Kemp, C.D. (1986). `A modal method for generating binomial !            variables', Commun. Statist. - Theor. Meth. 15(3), 805-813. INTEGER , INTENT ( IN ) :: n REAL , INTENT ( IN ) :: p LOGICAL , INTENT ( IN ) :: first INTEGER :: ival !     Local variables INTEGER :: ru , rd INTEGER , SAVE :: r0 REAL :: u , pd , pu REAL , SAVE :: odds_ratio , p_r REAL , PARAMETER :: zero = 0.0 , one = 1.0 IF ( first ) THEN r0 = ( n + 1 ) * p p_r = bin_prob ( n , p , r0 ) odds_ratio = p / ( one - p ) END IF CALL RANDOM_NUMBER ( u ) u = u - p_r IF ( u < zero ) THEN ival = r0 RETURN END IF pu = p_r ru = r0 pd = p_r rd = r0 DO rd = rd - 1 IF ( rd >= 0 ) THEN pd = pd * ( rd + 1 ) / ( odds_ratio * ( n - rd )) u = u - pd IF ( u < zero ) THEN ival = rd RETURN END IF END IF ru = ru + 1 IF ( ru <= n ) THEN pu = pu * ( n - ru + 1 ) * odds_ratio / ru u = u - pu IF ( u < zero ) THEN ival = ru RETURN END IF END IF END DO !     This point should not be reached, but just in case: ival = r0 RETURN END FUNCTION random_binomial1 FUNCTION bin_prob ( n , p , r ) RESULT ( fn_val ) !     Calculate a binomial probability INTEGER , INTENT ( IN ) :: n , r REAL , INTENT ( IN ) :: p REAL :: fn_val !     Local variable REAL :: one = 1.0 fn_val = EXP ( lngamma ( DBLE ( n + 1 )) - lngamma ( DBLE ( r + 1 )) - lngamma ( DBLE ( n - r + 1 )) & + r * LOG ( p ) + ( n - r ) * LOG ( one - p ) ) RETURN END FUNCTION bin_prob FUNCTION lngamma ( x ) RESULT ( fn_val ) ! Logarithm to base e of the gamma function. ! ! Accurate to about 1.e-14. ! Programmer: Alan Miller ! Latest revision of Fortran 77 version - 28 February 1988 REAL ( dp ), INTENT ( IN ) :: x REAL ( dp ) :: fn_val !       Local variables REAL ( dp ) :: a1 = - 4.166666666554424D-02 , a2 = 2.430554511376954D-03 , & a3 = - 7.685928044064347D-04 , a4 = 5.660478426014386D-04 , & temp , arg , product , lnrt2pi = 9.189385332046727D-1 , & pi = 3.141592653589793D0 LOGICAL :: reflect !       lngamma is not defined if x = 0 or a negative integer. IF ( x > 0.d0 ) GO TO 10 IF ( x /= INT ( x )) GO TO 10 fn_val = 0.d0 RETURN !       If x < 0, use the reflection formula: !               gamma(x) * gamma(1-x) = pi * cosec(pi.x) 10 reflect = ( x < 0.d0 ) IF ( reflect ) THEN arg = 1.d0 - x ELSE arg = x END IF !       Increase the argument, if necessary, to make it > 10. product = 1.d0 20 IF ( arg <= 1 0.d0 ) THEN product = product * arg arg = arg + 1.d0 GO TO 20 END IF !  Use a polynomial approximation to Stirling's formula. !  N.B. The real Stirling's formula is used here, not the simpler, but less !       accurate formula given by De Moivre in a letter to Stirling, which !       is the one usually quoted. arg = arg - 0.5D0 temp = 1.d0 / arg ** 2 fn_val = lnrt2pi + arg * ( LOG ( arg ) - 1.d0 + & ((( a4 * temp + a3 ) * temp + a2 ) * temp + a1 ) * temp ) - LOG ( product ) IF ( reflect ) THEN temp = SIN ( pi * x ) fn_val = LOG ( pi / temp ) - fn_val END IF RETURN END FUNCTION lngamma FUNCTION random_binomial2 ( n , pp , first ) RESULT ( ival ) !********************************************************************** !     Translated to Fortran 90 by Alan Miller from: !                              RANLIB ! !     Library of Fortran Routines for Random Number Generation ! !                      Compiled and Written by: ! !                           Barry W. Brown !                            James Lovato ! !               Department of Biomathematics, Box 237 !               The University of Texas, M.D. Anderson Cancer Center !               1515 Holcombe Boulevard !               Houston, TX      77030 ! ! This work was supported by grant CA-16672 from the National Cancer Institute. !                    GENerate BINomial random deviate !                              Function !     Generates a single random deviate from a binomial !     distribution whose number of trials is N and whose !     probability of an event in each trial is P. !                              Arguments !     N  --> The number of trials in the binomial distribution !            from which a random deviate is to be generated. !                              INTEGER N !     P  --> The probability of an event in each trial of the !            binomial distribution from which a random deviate !            is to be generated. !                              REAL P !     FIRST --> Set FIRST = .TRUE. for the first call to perform initialization !               the set FIRST = .FALSE. for further calls using the same pair !               of parameter values (N, P). !                              LOGICAL FIRST !     random_binomial2 <-- A random deviate yielding the number of events !                from N independent trials, each of which has !                a probability of event P. !                              INTEGER random_binomial !                              Method !     This is algorithm BTPE from: !         Kachitvichyanukul, V. and Schmeiser, B. W. !         Binomial Random Variate Generation. !         Communications of the ACM, 31, 2 (February, 1988) 216. !********************************************************************** !*****DETERMINE APPROPRIATE ALGORITHM AND WHETHER SETUP IS NECESSARY !     .. !     .. Scalar Arguments .. REAL , INTENT ( IN ) :: pp INTEGER , INTENT ( IN ) :: n LOGICAL , INTENT ( IN ) :: first INTEGER :: ival !     .. !     .. Local Scalars .. REAL :: alv , amaxp , f , f1 , f2 , u , v , w , w2 , x , x1 , x2 , ynorm , z , z2 REAL , PARAMETER :: zero = 0.0 , half = 0.5 , one = 1.0 INTEGER :: i , ix , ix1 , k , mp INTEGER , SAVE :: m REAL , SAVE :: p , q , xnp , ffm , fm , xnpq , p1 , xm , xl , xr , c , al , xll , & xlr , p2 , p3 , p4 , qn , r , g !     .. !     .. Executable Statements .. !*****SETUP, PERFORM ONLY WHEN PARAMETERS CHANGE IF ( first ) THEN p = MIN ( pp , one - pp ) q = one - p xnp = n * p END IF IF ( xnp > 3 0. ) THEN IF ( first ) THEN ffm = xnp + p m = ffm fm = m xnpq = xnp * q p1 = INT ( 2.195 * SQRT ( xnpq ) - 4.6 * q ) + half xm = fm + half xl = xm - p1 xr = xm + p1 c = 0.134 + 2 0.5 / ( 1 5.3 + fm ) al = ( ffm - xl ) / ( ffm - xl * p ) xll = al * ( one + half * al ) al = ( xr - ffm ) / ( xr * q ) xlr = al * ( one + half * al ) p2 = p1 * ( one + c + c ) p3 = p2 + c / xll p4 = p3 + c / xlr END IF !*****GENERATE VARIATE, Binomial mean at least 30. 20 CALL RANDOM_NUMBER ( u ) u = u * p4 CALL RANDOM_NUMBER ( v ) !     TRIANGULAR REGION IF ( u <= p1 ) THEN ix = xm - p1 * v + u GO TO 110 END IF !     PARALLELOGRAM REGION IF ( u <= p2 ) THEN x = xl + ( u - p1 ) / c v = v * c + one - ABS ( xm - x ) / p1 IF ( v > one . OR . v <= zero ) GO TO 20 ix = x ELSE !     LEFT TAIL IF ( u <= p3 ) THEN ix = xl + LOG ( v ) / xll IF ( ix < 0 ) GO TO 20 v = v * ( u - p2 ) * xll ELSE !     RIGHT TAIL ix = xr - LOG ( v ) / xlr IF ( ix > n ) GO TO 20 v = v * ( u - p3 ) * xlr END IF END IF !*****DETERMINE APPROPRIATE WAY TO PERFORM ACCEPT/REJECT TEST k = ABS ( ix - m ) IF ( k <= 20 . OR . k >= xnpq / 2 - 1 ) THEN !     EXPLICIT EVALUATION f = one r = p / q g = ( n + 1 ) * r IF ( m < ix ) THEN mp = m + 1 DO i = mp , ix f = f * ( g / i - r ) END DO ELSE IF ( m > ix ) THEN ix1 = ix + 1 DO i = ix1 , m f = f / ( g / i - r ) END DO END IF IF ( v > f ) THEN GO TO 20 ELSE GO TO 110 END IF END IF !     SQUEEZING USING UPPER AND LOWER BOUNDS ON LOG(F(X)) amaxp = ( k / xnpq ) * (( k * ( k / 3. + . 625 ) + . 1666666666666 ) / xnpq + half ) ynorm = - k * k / ( 2. * xnpq ) alv = LOG ( v ) IF ( alv < ynorm - amaxp ) GO TO 110 IF ( alv > ynorm + amaxp ) GO TO 20 !     STIRLING'S (actually de Moivre's) FORMULA TO MACHINE ACCURACY FOR !     THE FINAL ACCEPTANCE/REJECTION TEST x1 = ix + 1 f1 = fm + one z = n + 1 - fm w = n - ix + one z2 = z * z x2 = x1 * x1 f2 = f1 * f1 w2 = w * w IF ( alv - ( xm * LOG ( f1 / x1 ) + ( n - m + half ) * LOG ( z / w ) + ( ix - m ) * LOG ( w * p / ( x1 * q )) + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / f2 ) / f2 ) / f2 ) / f2 ) / f1 / 16632 0. + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / z2 ) / z2 ) / z2 ) / z2 ) / z / 16632 0. + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / x2 ) / x2 ) / x2 ) / x2 ) / x1 / 16632 0. + & ( 1386 0. - ( 46 2. - ( 13 2. - ( 9 9. - 14 0. / w2 ) / w2 ) / w2 ) / w2 ) / w / 16632 0. ) > zero ) THEN GO TO 20 ELSE GO TO 110 END IF ELSE !     INVERSE CDF LOGIC FOR MEAN LESS THAN 30 IF ( first ) THEN qn = q ** n r = p / q g = r * ( n + 1 ) END IF 90 ix = 0 f = qn CALL RANDOM_NUMBER ( u ) 100 IF ( u >= f ) THEN IF ( ix > 110 ) GO TO 90 u = u - f ix = ix + 1 f = f * ( g / ix - r ) GO TO 100 END IF END IF 110 IF ( pp > half ) ix = n - ix ival = ix RETURN END FUNCTION random_binomial2 FUNCTION random_neg_binomial ( sk , p ) RESULT ( ival ) ! Adapted from Fortran 77 code from the book: !     Dagpunar, J. 'Principles of random variate generation' !     Clarendon Press, Oxford, 1988.   ISBN 0-19-852202-9 ! FUNCTION GENERATES A RANDOM NEGATIVE BINOMIAL VARIATE USING UNSTORED ! INVERSION AND/OR THE REPRODUCTIVE PROPERTY. !    SK = NUMBER OF FAILURES REQUIRED (Dagpunar's words!) !       = the `power' parameter of the negative binomial !           (0 < REAL) !    P = BERNOULLI SUCCESS PROBABILITY !           (0 < REAL < 1) ! THE PARAMETER H IS SET SO THAT UNSTORED INVERSION ONLY IS USED WHEN P <= H, ! OTHERWISE A COMBINATION OF UNSTORED INVERSION AND ! THE REPRODUCTIVE PROPERTY IS USED. REAL , INTENT ( IN ) :: sk , p INTEGER :: ival !     Local variables ! THE PARAMETER ULN = -LOG(MACHINE'S SMALLEST REAL NUMBER). REAL , PARAMETER :: h = 0.7 REAL :: q , x , st , uln , v , r , s , y , g INTEGER :: k , i , n IF ( sk <= zero . OR . p <= zero . OR . p >= one ) THEN WRITE ( * , * ) 'IMPERMISSIBLE DISTRIBUTION PARAMETER VALUES' STOP END IF q = one - p x = zero st = sk IF ( p > h ) THEN v = one / LOG ( p ) k = st DO i = 1 , k DO CALL RANDOM_NUMBER ( r ) IF ( r > zero ) EXIT END DO n = v * LOG ( r ) x = x + n END DO st = st - k END IF s = zero uln = - LOG ( vsmall ) IF ( st > - uln / LOG ( q )) THEN WRITE ( * , * ) ' P IS TOO LARGE FOR THIS VALUE OF SK' STOP END IF y = q ** st g = st CALL RANDOM_NUMBER ( r ) DO IF ( y > r ) EXIT r = r - y s = s + one y = y * p * g / s g = g + one END DO ival = x + s + half RETURN END FUNCTION random_neg_binomial FUNCTION random_von_Mises ( k , first ) RESULT ( fn_val ) !     Algorithm VMD from: !     Dagpunar, J.S. (1990) `Sampling from the von Mises distribution via a !     comparison of random numbers', J. of Appl. Statist., 17, 165-168. !     Fortran 90 code by Alan Miller !     CSIRO Division of Mathematical & Information Sciences !     Arguments: !     k (real)        parameter of the von Mises distribution. !     first (logical) set to .TRUE. the first time that the function !                     is called, or the first time with a new value !                     for k.   When first = .TRUE., the function sets !                     up starting values and may be very much slower. REAL , INTENT ( IN ) :: k LOGICAL , INTENT ( IN ) :: first REAL :: fn_val !     Local variables INTEGER :: j , n INTEGER , SAVE :: nk REAL , PARAMETER :: pi = 3.14159265 REAL , SAVE :: p ( 20 ), theta ( 0 : 20 ) REAL :: sump , r , th , lambda , rlast REAL ( dp ) :: dk IF ( first ) THEN ! Initialization, if necessary IF ( k < zero ) THEN WRITE ( * , * ) '** Error: argument k for random_von_Mises = ' , k RETURN END IF nk = k + k + one IF ( nk > 20 ) THEN WRITE ( * , * ) '** Error: argument k for random_von_Mises = ' , k RETURN END IF dk = k theta ( 0 ) = zero IF ( k > half ) THEN !     Set up array p of probabilities. sump = zero DO j = 1 , nk IF ( j < nk ) THEN theta ( j ) = ACOS ( one - j / k ) ELSE theta ( nk ) = pi END IF !     Numerical integration of e&#94;[k.cos(x)] from theta(j-1) to theta(j) CALL integral ( theta ( j - 1 ), theta ( j ), p ( j ), dk ) sump = sump + p ( j ) END DO p ( 1 : nk ) = p ( 1 : nk ) / sump ELSE p ( 1 ) = one theta ( 1 ) = pi END IF ! if k > 0.5 END IF ! if first CALL RANDOM_NUMBER ( r ) DO j = 1 , nk r = r - p ( j ) IF ( r < zero ) EXIT END DO r = - r / p ( j ) DO th = theta ( j - 1 ) + r * ( theta ( j ) - theta ( j - 1 )) lambda = k - j + one - k * COS ( th ) n = 1 rlast = lambda DO CALL RANDOM_NUMBER ( r ) IF ( r > rlast ) EXIT n = n + 1 rlast = r END DO IF ( n . NE . 2 * ( n / 2 )) EXIT ! is n even? CALL RANDOM_NUMBER ( r ) END DO fn_val = SIGN ( th , ( r - rlast ) / ( one - rlast ) - half ) RETURN END FUNCTION random_von_Mises SUBROUTINE integral ( a , b , result , dk ) !     Gaussian integration of exp(k.cosx) from a to b. REAL ( dp ), INTENT ( IN ) :: dk REAL , INTENT ( IN ) :: a , b REAL , INTENT ( OUT ) :: result !     Local variables REAL ( dp ) :: xmid , range , x1 , x2 , & x ( 3 ) = ( / 0.238619186083197_dp , 0.661209386466265_dp , 0.932469514203152_dp / ), & w ( 3 ) = ( / 0.467913934572691_dp , 0.360761573048139_dp , 0.171324492379170_dp / ) INTEGER :: i xmid = ( a + b ) / 2._dp range = ( b - a ) / 2._dp result = 0._dp DO i = 1 , 3 x1 = xmid + x ( i ) * range x2 = xmid - x ( i ) * range result = result + w ( i ) * ( EXP ( dk * COS ( x1 )) + EXP ( dk * COS ( x2 ))) END DO result = result * range RETURN END SUBROUTINE integral FUNCTION random_Cauchy () RESULT ( fn_val ) !     Generate a random deviate from the standard Cauchy distribution REAL :: fn_val !     Local variables REAL :: v ( 2 ) DO CALL RANDOM_NUMBER ( v ) v = two * ( v - half ) IF ( ABS ( v ( 2 )) < vsmall ) CYCLE ! Test for zero IF ( v ( 1 ) ** 2 + v ( 2 ) ** 2 < one ) EXIT END DO fn_val = v ( 1 ) / v ( 2 ) RETURN END FUNCTION random_Cauchy SUBROUTINE random_order ( order , n ) !     Generate a random ordering of the integers 1 ... n. INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( OUT ) :: order ( n ) !     Local variables INTEGER :: i , j , k REAL :: wk DO i = 1 , n order ( i ) = i END DO !     Starting at the end, swap the current last indicator with one !     randomly chosen from those preceeding it. DO i = n , 2 , - 1 CALL RANDOM_NUMBER ( wk ) j = 1 + int ( i * wk ) IF ( j < i ) THEN k = order ( i ) order ( i ) = order ( j ) order ( j ) = k END IF END DO RETURN END SUBROUTINE random_order SUBROUTINE seed_random_number ( iounit ) INTEGER , INTENT ( IN ) :: iounit ! Local variables INTEGER :: k INTEGER , ALLOCATABLE :: seed (:) CALL RANDOM_SEED ( SIZE = k ) ALLOCATE ( seed ( k ) ) WRITE ( * , '(a, i2, a)' ) ' Enter ' , k , ' integers for random no. seeds: ' READ ( * , * ) seed WRITE ( iounit , '(a, (7i10))' ) ' Random no. seeds: ' , seed CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) RETURN END SUBROUTINE seed_random_number END MODULE random","tags":"","loc":"sourcefile/random.f90.html"},{"title":"fffc_linalg_rinv.f90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_rinv Source Code fffc_linalg_rinv.f90 Source Code submodule ( fffc_linalg ) fffc_linalg_rinv contains module procedure rinv_real_kind real ( kind = fffc_real_kind ) :: Ainv ( size ( x , 1 ), size ( x , 1 )) y = transpose ( x ) Ainv = gemm ( x , y ) call inv ( Ainv ) y = gemm ( y , Ainv ) end procedure rinv_real_kind module procedure rinv_complex_kind complex ( kind = fffc_complex_kind ) :: Ainv ( size ( x , 1 ), size ( x , 1 )) y = transpose ( x ) Ainv = gemm ( x , y ) call inv ( Ainv ) y = gemm ( y , Ainv ) end procedure rinv_complex_kind end submodule fffc_linalg_rinv","tags":"","loc":"sourcefile/fffc_linalg_rinv.f90.html"},{"title":"fffc_filesystem_is_windows.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_is_windows Source Code fffc_filesystem_is_windows.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_is_windows contains module procedure is_windows character ( 16 ) :: os_name logical , save :: is_windows_ = . false . logical , save :: is_first_run = . true . if ( is_first_run ) then call get_environment_variable ( \"OS\" , os_name ) is_windows_ = trim ( os_name ) == \"Windows_NT\" is_first_run = . false . is_windows = is_windows_ else is_windows = is_windows_ end if end procedure is_windows end submodule fffc_filesystem_is_windows","tags":"","loc":"sourcefile/fffc_filesystem_is_windows.f90.html"},{"title":"fffc_random_randn.f90 – Fortran free function collection","text":"Contents Submodules fffc_random_randn Source Code fffc_random_randn.f90 Source Code submodule ( fffc_random ) fffc_random_randn contains module procedure randn x = mean + std * random_normal () end procedure randn end submodule fffc_random_randn","tags":"","loc":"sourcefile/fffc_random_randn.f90.html"},{"title":"fffc_random.f90 – Fortran free function collection","text":"Contents Modules fffc_random Source Code fffc_random.f90 Source Code module fffc_random use fffc_kinds use random private public :: randn , randu interface impure elemental module subroutine randn ( x , mean , std ) real ( kind = fffc_real_kind ), intent ( out ) :: x real ( kind = fffc_real_kind ), intent ( in ) :: mean , std end subroutine randn impure elemental module subroutine randu ( x , min , max ) real ( kind = fffc_real_kind ), intent ( out ) :: x real ( kind = fffc_real_kind ), intent ( in ) :: min , max end subroutine randu end interface end module fffc_random","tags":"","loc":"sourcefile/fffc_random.f90.html"},{"title":"fffc_linalg_linv.f90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_linv Source Code fffc_linalg_linv.f90 Source Code submodule ( fffc_linalg ) fffc_linalg_linv contains module procedure linv_real_kind real ( kind = fffc_real_kind ) :: Ainv ( size ( x , 2 ), size ( x , 2 )) y = transpose ( x ) Ainv = gemm ( y , x ) call inv ( Ainv ) y = gemm ( Ainv , y ) end procedure linv_real_kind module procedure linv_complex_kind complex ( kind = fffc_complex_kind ) :: Ainv ( size ( x , 2 ), size ( x , 2 )) y = transpose ( x ) Ainv = gemm ( y , x ) call inv ( Ainv ) y = gemm ( Ainv , y ) end procedure linv_complex_kind end submodule fffc_linalg_linv","tags":"","loc":"sourcefile/fffc_linalg_linv.f90.html"},{"title":"fffc_string.f90 – Fortran free function collection","text":"Contents Modules fffc_string Source Code fffc_string.f90 Source Code module fffc_string use fffc_kinds interface to_string module function to_string_real_kind ( real , fmt ) result ( string ) real ( kind = fffc_real_kind ), intent ( in ) :: real character ( len =* ), intent ( in ) :: fmt character ( len = :), allocatable :: string end function to_string_real_kind module function to_string_int_kind ( int , fmt ) result ( string ) integer ( kind = fffc_int_kind ), intent ( in ) :: int character ( len =* ), intent ( in ) :: fmt character ( len = :), allocatable :: string end function to_string_int_kind module function to_string_logical_kind ( logical , fmt ) result ( string ) logical , intent ( in ) :: logical character ( len =* ), intent ( in ) :: fmt character ( len = :), allocatable :: string end function to_string_logical_kind end interface to_string interface pure module function to_lower ( string ) result ( lower ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: lower end function to_lower pure module function to_upper ( string ) result ( upper ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: upper end function to_upper end interface end module fffc_string","tags":"","loc":"sourcefile/fffc_string.f90.html"},{"title":"fffc_linalg_inv_func.f90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_inv_func Source Code fffc_linalg_inv_func.f90 Source Code submodule ( fffc_linalg ) fffc_linalg_inv_func contains module procedure inv_func_real_kind b = a call inv ( b ) end procedure inv_func_real_kind module procedure inv_func_complex_kind b = a call inv ( b ) end procedure inv_func_complex_kind end submodule fffc_linalg_inv_func","tags":"","loc":"sourcefile/fffc_linalg_inv_func.f90.html"},{"title":"fffc_random_randu.f90 – Fortran free function collection","text":"Contents Submodules fffc_random_randu Source Code fffc_random_randu.f90 Source Code submodule ( fffc_random ) fffc_random_randu contains module procedure randu call random_number ( x ) x = min + x * ( max - min ) end procedure randu end submodule fffc_random_randu","tags":"","loc":"sourcefile/fffc_random_randu.f90.html"},{"title":"fffc_linalg.f90 – Fortran free function collection","text":"Contents Modules fffc_linalg Source Code fffc_linalg.f90 Source Code module fffc_linalg use iso_fortran_env , only : int8 use fffc_kinds private :: int8 interface inv module subroutine inv_real_kind ( a ) real ( kind = fffc_real_kind ), intent ( inout ) :: a (:,:) end subroutine inv_real_kind module subroutine inv_complex_kind ( a ) complex ( kind = fffc_complex_kind ), intent ( inout ) :: a (:,:) end subroutine inv_complex_kind end interface inv interface inv_func module function inv_func_real_kind ( a ) result ( b ) real ( kind = fffc_real_kind ), intent ( in ) :: a (:,:) real ( kind = fffc_real_kind ) :: b ( size ( a , 1 ), size ( a , 2 )) end function inv_func_real_kind module function inv_func_complex_kind ( a ) result ( b ) complex ( kind = fffc_complex_kind ), intent ( in ) :: a (:,:) complex ( kind = fffc_complex_kind ) :: b ( size ( a , 1 ), size ( a , 2 )) end function inv_func_complex_kind end interface inv_func interface linv !! m > n, 列满秩，使用 linv module function linv_real_kind ( x ) result ( y ) real ( kind = fffc_real_kind ), intent ( in ) :: x (:, :) real ( kind = fffc_real_kind ) :: y ( size ( x , 2 ), size ( x , 1 )) end function linv_real_kind module function linv_complex_kind ( x ) result ( y ) complex ( kind = fffc_complex_kind ), intent ( in ) :: x (:, :) complex ( kind = fffc_complex_kind ) :: y ( size ( x , 2 ), size ( x , 1 )) end function linv_complex_kind end interface linv interface rinv !! m < n, 行满秩，使用 rinv module function rinv_real_kind ( x ) result ( y ) real ( kind = fffc_real_kind ), intent ( in ) :: x (:, :) real ( kind = fffc_real_kind ) :: y ( size ( x , 2 ), size ( x , 1 )) end function rinv_real_kind module function rinv_complex_kind ( x ) result ( y ) complex ( kind = fffc_complex_kind ), intent ( in ) :: x (:, :) complex ( kind = fffc_complex_kind ) :: y ( size ( x , 2 ), size ( x , 1 )) end function rinv_complex_kind end interface rinv interface solve module subroutine solve_real_kind ( a , b ) real ( kind = fffc_real_kind ), intent ( inout ) :: a (:,:) real ( kind = fffc_real_kind ), intent ( inout ) :: b (:,:) end subroutine solve_real_kind module subroutine solve_complex_kind ( a , b ) complex ( kind = fffc_complex_kind ), intent ( inout ) :: a (:,:) complex ( kind = fffc_complex_kind ), intent ( inout ) :: b (:,:) end subroutine solve_complex_kind end interface solve interface solve_func module function solve_func_real_kind ( a , b ) result ( x ) real ( kind = fffc_real_kind ), intent ( in ) :: a (:,:) real ( kind = fffc_real_kind ), intent ( in ) :: b (:,:) real ( kind = fffc_real_kind ) :: x ( size ( b , 1 ), size ( b , 2 )) end function solve_func_real_kind module function solve_func_complex_kind ( a , b ) result ( x ) complex ( kind = fffc_complex_kind ), intent ( in ) :: a (:,:) complex ( kind = fffc_complex_kind ), intent ( in ) :: b (:,:) complex ( kind = fffc_complex_kind ) :: x ( size ( b , 1 ), size ( b , 2 )) end function solve_func_complex_kind end interface solve_func interface diag pure module function diag_rank1 ( v ) result ( a ) real ( kind = fffc_real_kind ), intent ( in ) :: v (:) real ( kind = fffc_real_kind ) :: a ( size ( v ), size ( v )) end function diag_rank1 pure module function diag_rank2 ( a ) result ( v ) real ( kind = fffc_real_kind ), intent ( in ) :: a (:,:) real ( kind = fffc_real_kind ) :: v ( min ( size ( a , 1 ), size ( a , 2 ))) end function diag_rank2 end interface diag interface gemm module function rrgemm ( a , b ) result ( c ) real ( kind = fffc_real_kind ), intent ( in ) :: a (:,:), b (:,:) real ( kind = fffc_real_kind ) :: c ( size ( a , 1 ), size ( b , 2 )) end function rrgemm module function ccgemm ( a , b ) result ( c ) complex ( kind = fffc_complex_kind ), intent ( in ) :: a (:,:), b (:,:) complex ( kind = fffc_complex_kind ) :: c ( size ( a , 1 ), size ( b , 2 )) end function ccgemm module function crgemm ( a , b ) result ( c ) complex ( kind = fffc_complex_kind ), intent ( in ) :: a (:,:) real ( kind = fffc_real_kind ), intent ( in ) :: b (:,:) complex ( kind = fffc_complex_kind ) :: c ( size ( a , 1 ), size ( b , 2 )) end function crgemm module function rcgemm ( a , b ) result ( c ) real ( kind = fffc_real_kind ), intent ( in ) :: a (:,:) complex ( kind = fffc_complex_kind ), intent ( in ) :: b (:,:) complex ( kind = fffc_complex_kind ) :: c ( size ( a , 1 ), size ( b , 2 )) end function rcgemm end interface gemm interface module function det ( a ) result ( ans ) real ( kind = fffc_real_kind ), intent ( inout ) :: a (:,:) real ( kind = fffc_real_kind ) :: ans end function det pure module function eye ( m , n ) result ( a ) integer , intent ( in ) :: m , n integer ( kind = int8 ) :: a ( m , n ) end function eye end interface end module fffc_linalg","tags":"","loc":"sourcefile/fffc_linalg.f90.html"},{"title":"fffc_filesystem_join.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_join Source Code fffc_filesystem_join.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_join contains module procedure join join = trim ( path ) // \"/\" // trim ( name ) end procedure join end submodule fffc_filesystem_join","tags":"","loc":"sourcefile/fffc_filesystem_join.f90.html"},{"title":"fffc_math_linspace.f90 – Fortran free function collection","text":"Contents Submodules fffc_math_linspace Source Code fffc_math_linspace.f90 Source Code submodule ( fffc_math ) fffc_math_linspace contains module procedure linspace_real_kind real ( kind = fffc_real_kind ) :: step integer :: i if ( n <= 0 ) then return elseif ( n == 1 ) then ans ( 1 ) = start return end if step = ( stop - start ) / real ( n - 1 , kind = fffc_real_kind ) do i = 1 , n ans ( i ) = start + real ( i - 1 , kind = fffc_real_kind ) * step end do end procedure linspace_real_kind module procedure linspace_int_kind integer ( kind = fffc_int_kind ) :: step integer :: i if ( n <= 0 ) then return elseif ( n == 1 ) then ans ( 1 ) = start return end if step = ( stop - start ) / ( n - 1 ) do i = 1 , n ans ( i ) = start + ( i - 1 ) * step end do end procedure linspace_int_kind end submodule fffc_math_linspace","tags":"","loc":"sourcefile/fffc_math_linspace.f90.html"},{"title":"fffc_math_cross_product.f90 – Fortran free function collection","text":"Contents Submodules fffc_math_cross_product Source Code fffc_math_cross_product.f90 Source Code submodule ( fffc_math ) fffc_math_cross_product contains module procedure cross_product_real_kind ans ( 1 ) = v1 ( 2 ) * v2 ( 3 ) - v1 ( 3 ) * v2 ( 2 ) ans ( 2 ) = v1 ( 3 ) * v2 ( 1 ) - v1 ( 1 ) * v2 ( 3 ) ans ( 3 ) = v1 ( 1 ) * v2 ( 2 ) - v1 ( 2 ) * v2 ( 1 ) end procedure cross_product_real_kind module procedure cross_product_int_kind ans ( 1 ) = v1 ( 2 ) * v2 ( 3 ) - v1 ( 3 ) * v2 ( 2 ) ans ( 2 ) = v1 ( 3 ) * v2 ( 1 ) - v1 ( 1 ) * v2 ( 3 ) ans ( 3 ) = v1 ( 1 ) * v2 ( 2 ) - v1 ( 2 ) * v2 ( 1 ) end procedure cross_product_int_kind end submodule fffc_math_cross_product","tags":"","loc":"sourcefile/fffc_math_cross_product.f90.html"},{"title":"fffc_filesystem.f90 – Fortran free function collection","text":"Contents Modules fffc_filesystem Source Code fffc_filesystem.f90 Source Code !> 文件系统 module fffc_filesystem implicit none interface module function is_windows () logical :: is_windows end function is_windows module subroutine mkdir ( path ) character ( len =* ), intent ( in ) :: path end subroutine mkdir module subroutine rmdir ( path ) character ( len =* ), intent ( in ) :: path end subroutine rmdir module function exists ( file , is_directory ) character ( len =* ), intent ( in ) :: file logical , intent ( in ), optional :: is_directory logical :: exists end function exists integer module function countlines ( file ) character ( len =* ), intent ( in ) :: file end function countlines pure module function unix_path ( path ) character ( len =* ), intent ( in ) :: path character ( len = len ( path )) :: unix_path end function unix_path pure module function dirname ( path ) result ( dir ) character ( len =* ), intent ( in ) :: path character ( len = :), allocatable :: dir end function dirname pure module function basename ( path ) result ( base ) character ( len =* ), intent ( in ) :: path character ( len = :), allocatable :: base end function basename end interface interface operator (. join .) module function join ( path , name ) character ( len =* ), intent ( in ) :: path character ( len =* ), intent ( in ) :: name character ( len = len ( path ) + len ( name ) + 1 ) :: join end function join end interface end module fffc_filesystem","tags":"","loc":"sourcefile/fffc_filesystem.f90.html"},{"title":"fffc_utils_is_env.f90 – Fortran free function collection","text":"Contents Submodules fffc_utils_is_env Source Code fffc_utils_is_env.f90 Source Code submodule ( fffc_utils ) fffc_utils_is_env contains module procedure is_env integer :: stat character ( len = 64 ) :: value call get_environment_variable ( key , value , status = stat ) if ( stat == 0 ) then is_env = . true . else is_env = . false . end if end procedure is_env end submodule fffc_utils_is_env","tags":"","loc":"sourcefile/fffc_utils_is_env.f90.html"},{"title":"fffc_filesystem_rmdir.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_rmdir Source Code fffc_filesystem_rmdir.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_rmdir contains module procedure rmdir if ( is_windows ()) then call execute_command_line ( \"rd /s /q \" // path ) else call execute_command_line ( \"rm -rf \" // path ) end if end procedure rmdir end submodule fffc_filesystem_rmdir","tags":"","loc":"sourcefile/fffc_filesystem_rmdir.f90.html"},{"title":"fffc_stats.f90 – Fortran free function collection","text":"Contents Modules fffc_stats Source Code fffc_stats.f90 Source Code module fffc_stats use fffc_kinds interface mean pure module function mean_real_kind ( x ) real ( kind = fffc_real_kind ), intent ( in ) :: x (:) real ( kind = fffc_real_kind ) :: mean_real_kind end function mean_real_kind pure module function mean_int_kind ( x ) integer ( kind = fffc_int_kind ), intent ( in ) :: x (:) integer ( kind = fffc_int_kind ) :: mean_int_kind end function mean_int_kind end interface mean end module fffc_stats","tags":"","loc":"sourcefile/fffc_stats.f90.html"},{"title":"fffc_linalg_eye.f90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_eye Source Code fffc_linalg_eye.f90 Source Code submodule ( fffc_linalg ) fffc_linalg_eye contains module procedure eye integer :: i , j do j = 1 , n do i = 1 , m if ( i == j ) then a ( i , j ) = 1_int8 else a ( i , j ) = 0_int8 endif enddo enddo end procedure eye end submodule fffc_linalg_eye","tags":"","loc":"sourcefile/fffc_linalg_eye.f90.html"},{"title":"fffc_module.f90 – Fortran free function collection","text":"Contents Modules fffc_module Source Code fffc_module.f90 Source Code !> 功能汇总 module fffc_module use fffc_constants use fffc_filesystem use fffc_kinds use fffc_linalg use fffc_math use fffc_random use fffc_stats use fffc_string use fffc_terminal use fffc_time use fffc_utils use random use rkf45_module implicit none end module fffc_module","tags":"","loc":"sourcefile/fffc_module.f90.html"},{"title":"fffc_filesystem_dirname.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_dirname Source Code fffc_filesystem_dirname.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_dirname contains module procedure dirname integer :: ik , len_path len_path = len_trim ( path ) if ( len_path == 0 ) then dir = '.' else ik = index ( unix_path ( path ), '/' , back = . true .) if ( ik == 0 ) then dir = '.' else dir = path ( 1 : ik - 1 ) end if end if end procedure dirname end submodule fffc_filesystem_dirname","tags":"","loc":"sourcefile/fffc_filesystem_dirname.f90.html"},{"title":"fffc_constants.f90 – Fortran free function collection","text":"Contents Modules fffc_constants Source Code fffc_constants.f90 Source Code !> 常数 module fffc_constants use fffc_kinds , only : fffc_real_kind implicit none private public :: pi , g , rad2deg , deg2rad , sqrt_eps real ( kind = fffc_real_kind ), parameter :: pi = acos ( - 1.0_fffc_real_kind ) !! 圆周率 real ( kind = fffc_real_kind ), parameter :: g = 9.80665_fffc_real_kind !! 重力加速度, m/s&#94;2 real ( kind = fffc_real_kind ), parameter :: rad2deg = 18 0.0_fffc_real_kind / pi !! 弧度转角度 real ( kind = fffc_real_kind ), parameter :: deg2rad = pi / 18 0.0_fffc_real_kind !! 角度转弧度 real ( kind = fffc_real_kind ), parameter :: sqrt_eps = sqrt ( epsilon ( 1.0_fffc_real_kind )) !! 根号机器精度 end module fffc_constants","tags":"","loc":"sourcefile/fffc_constants.f90.html"},{"title":"fffc_utils.f90 – Fortran free function collection","text":"Contents Modules fffc_utils Source Code fffc_utils.f90 Source Code module fffc_utils use fffc_kinds interface swap elemental module subroutine swap_int_kind ( a , b ) integer ( kind = fffc_int_kind ), intent ( inout ) :: a integer ( kind = fffc_int_kind ), intent ( inout ) :: b end subroutine swap_int_kind elemental module subroutine swap_real_kind ( a , b ) real ( kind = fffc_real_kind ), intent ( inout ) :: a real ( kind = fffc_real_kind ), intent ( inout ) :: b end subroutine swap_real_kind end interface interface bubble_sort pure module subroutine bubble_sort_real_kind ( v ) real ( kind = fffc_real_kind ), intent ( inout ) :: v (:) end subroutine bubble_sort_real_kind pure module subroutine bubble_sort_int_kind ( v ) integer ( kind = fffc_int_kind ), intent ( inout ) :: v (:) end subroutine bubble_sort_int_kind end interface interface module function is_env ( key ) character ( len =* ), intent ( in ) :: key logical :: is_env end function is_env end interface end module fffc_utils","tags":"","loc":"sourcefile/fffc_utils.f90.html"},{"title":"fffc_utils_bubble_sort.f90 – Fortran free function collection","text":"Contents Submodules fffc_utils_bubble_sort Source Code fffc_utils_bubble_sort.f90 Source Code submodule ( fffc_utils ) fffc_utils_bubble_sort contains module procedure bubble_sort_real_kind integer :: i , j , n n = size ( v ) do i = 1 , n do j = 1 , n if ( v ( i ) > v ( j )) then call swap ( v ( i ), v ( j )) end if end do end do end procedure bubble_sort_real_kind module procedure bubble_sort_int_kind integer :: i , j , n n = size ( v ) do i = 1 , n do j = 1 , n if ( v ( i ) > v ( j )) then call swap ( v ( i ), v ( j )) end if end do end do end procedure bubble_sort_int_kind end submodule fffc_utils_bubble_sort","tags":"","loc":"sourcefile/fffc_utils_bubble_sort.f90.html"},{"title":"fffc_filesystem_mkdir.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_mkdir Source Code fffc_filesystem_mkdir.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_mkdir contains module procedure mkdir if ( is_windows ()) then call execute_command_line ( \"md \" // path ) else call execute_command_line ( \"mkdir -p \" // path ) end if end procedure mkdir end submodule fffc_filesystem_mkdir","tags":"","loc":"sourcefile/fffc_filesystem_mkdir.f90.html"},{"title":"fffc_filesystem_exists.F90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_exists Source Code fffc_filesystem_exists.F90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_exists contains module procedure exists #if defined __INTEL_COMPILER if ( present ( is_directory )) then if ( is_directory ) then inquire ( directory = file , exist = exists ) return end if end if #endif inquire ( file = file , exist = exists ) end procedure exists end submodule fffc_filesystem_exists","tags":"","loc":"sourcefile/fffc_filesystem_exists.f90.html"},{"title":"fffc_linalg_solve.F90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_solve Source Code fffc_linalg_solve.F90 Source Code #ifdef REAL64 #define sgesv dgesv #define cgesv zgesv #endif submodule ( fffc_linalg ) fffc_linalg_solve contains module procedure solve_real_kind integer :: ipiv ( size ( a , 1 )), info call sgesv ( size ( a , 1 ), size ( b , 2 ), a , size ( a , 1 ), ipiv , b , size ( b , 1 ), info ) end procedure solve_real_kind module procedure solve_complex_kind integer :: ipiv ( size ( a , 1 )), info call cgesv ( size ( a , 1 ), size ( b , 2 ), a , size ( a , 1 ), ipiv , b , size ( b , 1 ), info ) end procedure solve_complex_kind end submodule fffc_linalg_solve","tags":"","loc":"sourcefile/fffc_linalg_solve.f90.html"},{"title":"fffc_math.f90 – Fortran free function collection","text":"Contents Modules fffc_math Source Code fffc_math.f90 Source Code module fffc_math use fffc_kinds interface cross_product pure module function cross_product_real_kind ( v1 , v2 ) result ( ans ) real ( kind = fffc_real_kind ), intent ( in ) :: v1 ( 3 ) real ( kind = fffc_real_kind ), intent ( in ) :: v2 ( 3 ) real ( kind = fffc_real_kind ) :: ans ( 3 ) end function cross_product_real_kind pure module function cross_product_int_kind ( v1 , v2 ) result ( ans ) integer ( kind = fffc_int_kind ), intent ( in ) :: v1 ( 3 ) integer ( kind = fffc_int_kind ), intent ( in ) :: v2 ( 3 ) integer ( kind = fffc_int_kind ) :: ans ( 3 ) end function cross_product_int_kind end interface cross_product interface arange pure module function arange_real_kind ( start , stop , step ) result ( ans ) real ( kind = fffc_real_kind ), intent ( in ) :: start real ( kind = fffc_real_kind ), intent ( in ) :: stop real ( kind = fffc_real_kind ), intent ( in ), optional :: step real ( kind = fffc_real_kind ), allocatable :: ans (:) end function arange_real_kind pure module function arange_int_kind ( start , stop , step ) result ( ans ) integer ( kind = fffc_int_kind ), intent ( in ) :: start integer ( kind = fffc_int_kind ), intent ( in ) :: stop integer ( kind = fffc_int_kind ), intent ( in ), optional :: step integer ( kind = fffc_int_kind ), allocatable :: ans (:) end function arange_int_kind end interface arange interface diff pure module function diff_real_kind ( x , n , prepend , append ) result ( y ) real ( kind = fffc_real_kind ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n real ( kind = fffc_real_kind ), intent ( in ), optional :: prepend (:), append (:) real ( kind = fffc_real_kind ), allocatable :: y (:) end function diff_real_kind pure module function diff_int_kind ( x , n , prepend , append ) result ( y ) integer ( kind = fffc_int_kind ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n integer ( kind = fffc_int_kind ), intent ( in ), optional :: prepend (:), append (:) integer ( kind = fffc_int_kind ), allocatable :: y (:) end function diff_int_kind end interface diff interface linspace pure module function linspace_real_kind ( start , stop , n ) result ( ans ) real ( kind = fffc_real_kind ), intent ( in ) :: start real ( kind = fffc_real_kind ), intent ( in ) :: stop integer , intent ( in ) :: n real ( kind = fffc_real_kind ) :: ans ( max ( 0 , n )) end function linspace_real_kind pure module function linspace_int_kind ( start , stop , n ) result ( ans ) integer ( kind = fffc_int_kind ), intent ( in ) :: start integer ( kind = fffc_int_kind ), intent ( in ) :: stop integer , intent ( in ) :: n integer ( kind = fffc_int_kind ) :: ans ( max ( 0 , n )) end function linspace_int_kind end interface linspace interface elemental module function arg ( z ) complex ( kind = fffc_complex_kind ), intent ( in ) :: z real ( kind = fffc_real_kind ) :: arg end function arg elemental module function is_close ( a , b , rel_tol , abs_tol , equal_nan ) result ( close ) real ( kind = fffc_real_kind ), intent ( in ) :: a , b real ( kind = fffc_real_kind ), intent ( in ), optional :: rel_tol , abs_tol logical , intent ( in ), optional :: equal_nan logical :: close end function is_close end interface end module fffc_math","tags":"","loc":"sourcefile/fffc_math.f90.html"},{"title":"fffc_string_to_lower.f90 – Fortran free function collection","text":"Contents Submodules fffc_string_to_lower Source Code fffc_string_to_lower.f90 Source Code submodule ( fffc_string ) fffc_string_to_lower contains module procedure to_lower integer :: i do i = 1 , len ( string ) select case ( string ( i : i )) case ( 'A' : 'Z' ) lower ( i : i ) = char ( iachar ( string ( i : i )) + 32 ) case default lower ( i : i ) = string ( i : i ) end select end do end procedure to_lower end submodule fffc_string_to_lower","tags":"","loc":"sourcefile/fffc_string_to_lower.f90.html"},{"title":"fffc_utils_swap.f90 – Fortran free function collection","text":"Contents Submodules fffc_utils_swap Source Code fffc_utils_swap.f90 Source Code submodule ( fffc_utils ) fffc_utils_swap contains module procedure swap_int_kind integer ( kind = fffc_int_kind ) :: tmp tmp = a a = b b = tmp end procedure swap_int_kind module procedure swap_real_kind real ( kind = fffc_real_kind ) :: tmp tmp = a a = b b = tmp end procedure swap_real_kind end submodule fffc_utils_swap","tags":"","loc":"sourcefile/fffc_utils_swap.f90.html"},{"title":"fffc_linalg_solve_func.f90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_solve_func Source Code fffc_linalg_solve_func.f90 Source Code submodule ( fffc_linalg ) fffc_linalg_solve_func contains module procedure solve_func_real_kind real ( kind = fffc_real_kind ) :: a_local ( size ( a , 1 ), size ( a , 2 )) x = b a_local = a call solve ( a_local , x ) end procedure solve_func_real_kind module procedure solve_func_complex_kind complex ( kind = fffc_complex_kind ) :: a_local ( size ( a , 1 ), size ( a , 2 )) x = b a_local = a call solve ( a_local , x ) end procedure solve_func_complex_kind end submodule fffc_linalg_solve_func","tags":"","loc":"sourcefile/fffc_linalg_solve_func.f90.html"},{"title":"fffc_math_arg.f90 – Fortran free function collection","text":"Contents Submodules fffc_math_arg Source Code fffc_math_arg.f90 Source Code submodule ( fffc_math ) fffc_math_arg contains module procedure arg complex ( kind = fffc_complex_kind ), parameter :: zero = ( 0.0_fffc_real_kind , 0.0_fffc_real_kind ) if ( z == zero ) then arg = 0.0_fffc_real_kind else arg = atan2 ( z % im , z % re ) end if end procedure arg end submodule fffc_math_arg","tags":"","loc":"sourcefile/fffc_math_arg.f90.html"},{"title":"fffc_math_diff.f90 – Fortran free function collection","text":"Contents Submodules fffc_math_diff Source Code fffc_math_diff.f90 Source Code submodule ( fffc_math ) fffc_math_diff contains module procedure diff_real_kind integer :: size_prepend , size_append , size_x , size_work integer :: n_ , i if ( present ( n )) then n_ = n else n_ = 1 end if if ( n_ <= 0 ) then y = x return end if size_prepend = 0 size_append = 0 if ( present ( prepend )) size_prepend = size ( prepend ) if ( present ( append )) size_append = size ( append ) size_x = size ( x ) size_work = size_x + size_prepend + size_append if ( size_work <= n_ ) then allocate ( y ( 0 )) return end if !> Use a quick exit for the common case, to avoid memory allocation. if ( size_prepend == 0 . and . size_append == 0 . and . n_ == 1 ) then y = x ( 2 :) - x ( 1 : size_x - 1 ) return end if block real ( kind = fffc_real_kind ) :: work ( size_work ) if ( size_prepend > 0 ) work (: size_prepend ) = prepend work ( size_prepend + 1 : size_prepend + size_x ) = x if ( size_append > 0 ) work ( size_prepend + size_x + 1 :) = append do i = 1 , n_ work ( 1 : size_work - i ) = work ( 2 : size_work - i + 1 ) - work ( 1 : size_work - i ) end do y = work ( 1 : size_work - n_ ) end block end procedure diff_real_kind module procedure diff_int_kind integer :: size_prepend , size_append , size_x , size_work integer :: n_ , i if ( present ( n )) then n_ = n else n_ = 1 end if if ( n_ <= 0 ) then y = x return end if size_prepend = 0 size_append = 0 if ( present ( prepend )) size_prepend = size ( prepend ) if ( present ( append )) size_append = size ( append ) size_x = size ( x ) size_work = size_x + size_prepend + size_append if ( size_work <= n_ ) then allocate ( y ( 0 )) return end if !> Use a quick exit for the common case, to avoid memory allocation. if ( size_prepend == 0 . and . size_append == 0 . and . n_ == 1 ) then y = x ( 2 :) - x ( 1 : size_x - 1 ) return end if block integer ( kind = fffc_int_kind ) :: work ( size_work ) if ( size_prepend > 0 ) work (: size_prepend ) = prepend work ( size_prepend + 1 : size_prepend + size_x ) = x if ( size_append > 0 ) work ( size_prepend + size_x + 1 :) = append do i = 1 , n_ work ( 1 : size_work - i ) = work ( 2 : size_work - i + 1 ) - work ( 1 : size_work - i ) end do y = work ( 1 : size_work - n_ ) end block end procedure diff_int_kind end submodule fffc_math_diff","tags":"","loc":"sourcefile/fffc_math_diff.f90.html"},{"title":"fffc_filesystem_basename.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_basename Source Code fffc_filesystem_basename.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_basename contains module procedure basename integer :: ik , len_path len_path = len_trim ( path ) if ( len_path == 0 ) then base = '.' else ik = index ( unix_path ( path ), '/' , back = . true .) if ( ik == 0 ) then base = path else base = path ( ik + 1 : len_path ) end if end if end procedure basename end submodule fffc_filesystem_basename","tags":"","loc":"sourcefile/fffc_filesystem_basename.f90.html"},{"title":"fffc_math_is_close.f90 – Fortran free function collection","text":"Contents Submodules fffc_math_is_close Source Code fffc_math_is_close.f90 Source Code submodule ( fffc_math ) fffc_math_is_close use ieee_arithmetic , only : ieee_is_nan contains module procedure is_close real ( kind = fffc_real_kind ) :: abs_tol_ , rel_tol_ real ( kind = fffc_real_kind ), parameter :: sqrt_eps = sqrt ( epsilon ( 1.0_fffc_real_kind )) logical :: equal_nan_ if ( present ( equal_nan )) then equal_nan_ = equal_nan else equal_nan_ = . false . end if if ( ieee_is_nan ( a ) . or . ieee_is_nan ( b )) then close = merge (. true ., . false ., equal_nan_ . and . ieee_is_nan ( a ) . and . ieee_is_nan ( b )) else if ( present ( rel_tol )) then rel_tol_ = rel_tol else rel_tol_ = sqrt_eps end if if ( present ( abs_tol )) then abs_tol_ = abs_tol else abs_tol_ = 0.0_fffc_real_kind end if close = abs ( a - b ) <= max ( abs ( rel_tol_ * max ( abs ( a ), abs ( b ))), & abs ( abs_tol_ )) end if end procedure is_close end submodule fffc_math_is_close","tags":"","loc":"sourcefile/fffc_math_is_close.f90.html"},{"title":"fffc_stats_mean.f90 – Fortran free function collection","text":"Contents Submodules fffc_stats_mean Source Code fffc_stats_mean.f90 Source Code submodule ( fffc_stats ) fffc_stats_mean contains module procedure mean_real_kind mean_real_kind = sum ( x ) / size ( x ) end procedure mean_real_kind module procedure mean_int_kind mean_int_kind = sum ( x ) / size ( x ) end procedure mean_int_kind end submodule fffc_stats_mean","tags":"","loc":"sourcefile/fffc_stats_mean.f90.html"},{"title":"fffc_linalg_inv.F90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_inv Source Code fffc_linalg_inv.F90 Source Code #ifdef REAL64 #define sgetrf dgetrf #define sgetri dgetri #define cgetrf zgetrf #define cgetri zgetri #endif submodule ( fffc_linalg ) fffc_linalg_inv contains module procedure inv_real_kind integer :: ipiv ( size ( a , 1 )), info real ( kind = fffc_real_kind ) :: work ( size ( a , 2 )) call sgetrf ( size ( a , 1 ), size ( a , 2 ), a , size ( a , 1 ), ipiv , info ) call sgetri ( size ( a , 2 ), a , size ( a , 1 ), ipiv , work , size ( work ), info ) end procedure inv_real_kind module procedure inv_complex_kind integer :: ipiv ( size ( a , 1 )), info complex ( kind = fffc_complex_kind ) :: work ( size ( a , 2 )) call cgetrf ( size ( a , 1 ), size ( a , 2 ), a , size ( a , 1 ), ipiv , info ) call cgetri ( size ( a , 2 ), a , size ( a , 1 ), ipiv , work , size ( work ), info ) end procedure inv_complex_kind end submodule fffc_linalg_inv","tags":"","loc":"sourcefile/fffc_linalg_inv.f90.html"},{"title":"fffc_linalg_gemm.F90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_gemm Source Code fffc_linalg_gemm.F90 Source Code #ifdef REAL64 #define sgemm dgemm #define cgemm zgemm #endif submodule ( fffc_linalg ) fffc_linalg_gemm contains module procedure rrgemm integer :: m , n , k m = size ( a , 1 ) n = size ( b , 2 ) k = size ( a , 2 ) call sgemm ( 'N' , 'N' , m , n , k , 1.0_fffc_real_kind , a , m , b , k , 0.0_fffc_real_kind , c , m ) end procedure rrgemm module procedure ccgemm integer :: m , n , k m = size ( a , 1 ) n = size ( b , 2 ) k = size ( a , 2 ) call cgemm ( 'N' , 'N' , m , n , k , ( 1.0_fffc_complex_kind , 0.0_fffc_complex_kind ), a , m , b , k , & ( 0.0_fffc_complex_kind , 0.0_fffc_complex_kind ), c , m ) end procedure ccgemm module procedure crgemm integer :: m , n , k m = size ( a , 1 ) n = size ( b , 2 ) k = size ( a , 2 ) call cgemm ( 'N' , 'N' , m , n , k , ( 1.0_fffc_complex_kind , 0.0_fffc_complex_kind ), a , m , & cmplx ( b , kind = fffc_complex_kind ), k , & ( 0.0_fffc_complex_kind , 0.0_fffc_complex_kind ), c , m ) end procedure crgemm module procedure rcgemm integer :: m , n , k m = size ( a , 1 ) n = size ( b , 2 ) k = size ( a , 2 ) call cgemm ( 'N' , 'N' , m , n , k , ( 1.0_fffc_complex_kind , 0.0_fffc_complex_kind ), & cmplx ( a , kind = fffc_complex_kind ), m , b , k , & ( 0.0_fffc_complex_kind , 0.0_fffc_complex_kind ), c , m ) end procedure rcgemm end submodule fffc_linalg_gemm","tags":"","loc":"sourcefile/fffc_linalg_gemm.f90.html"},{"title":"fffc_linalg_diag.f90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_diag Source Code fffc_linalg_diag.f90 Source Code submodule ( fffc_linalg ) fffc_linalg_diag contains module procedure diag_rank1 integer :: i , j do j = 1 , size ( v ) do i = 1 , size ( v ) if ( i == j ) then a ( i , j ) = v ( i ) else a ( i , j ) = 0.0_fffc_real_kind end if end do end do end procedure diag_rank1 module procedure diag_rank2 integer :: i do i = 1 , size ( v ) v ( i ) = a ( i , i ) end do end procedure diag_rank2 end submodule fffc_linalg_diag","tags":"","loc":"sourcefile/fffc_linalg_diag.f90.html"},{"title":"fffc_time.f90 – Fortran free function collection","text":"Contents Modules fffc_time Source Code fffc_time.f90 Source Code module fffc_time use fffc_kinds type timer integer , private :: seed contains procedure :: tic , toc , nowtime end type timer contains subroutine tic ( self ) class ( timer ), intent ( out ) :: self call system_clock ( self % seed ) end subroutine tic function toc ( self ) class ( timer ), intent ( in ) :: self real ( kind = fffc_real_kind ) :: toc integer :: time_now , time_rate call system_clock ( time_now , time_rate ) toc = real ( time_now - self % seed , fffc_real_kind ) / time_rate end function toc character ( 23 ) function nowtime ( self ) result ( t ) class ( timer ), intent ( in ) :: self character ( len = 8 ) :: datstr character ( len = 10 ) :: timstr call date_and_time ( datstr , timstr ) t = datstr ( 1 : 4 ) // \"-\" // datstr ( 5 : 6 ) // \"-\" // datstr ( 7 : 8 ) // \" \" // & timstr ( 1 : 2 ) // \":\" // timstr ( 3 : 4 ) // \":\" // timstr ( 5 : 10 ) end function nowtime end module fffc_time","tags":"","loc":"sourcefile/fffc_time.f90.html"},{"title":"fffc_filesystem_countlines.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_countlines Source Code fffc_filesystem_countlines.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_countlines contains module procedure countlines integer :: istat , iunit open ( newunit = iunit , file = file , status = 'old' ) countlines = 0 do read ( iunit , * , iostat = istat ) if ( is_iostat_end ( istat )) exit countlines = countlines + 1 end do close ( iunit ) end procedure countlines end submodule fffc_filesystem_countlines","tags":"","loc":"sourcefile/fffc_filesystem_countlines.f90.html"},{"title":"fffc_filesystem_unix_path.f90 – Fortran free function collection","text":"Contents Submodules fffc_filesystem_unix_path Source Code fffc_filesystem_unix_path.f90 Source Code submodule ( fffc_filesystem ) fffc_filesystem_unix_path contains module procedure unix_path integer :: i do i = 1 , len ( path ) if ( path ( i : i ) == \"\\\") then unix_path(i:i) = \" / \" else unix_path ( i : i ) = path ( i : i ) end if end do end procedure unix_path end submodule fffc_filesystem_unix_path","tags":"","loc":"sourcefile/fffc_filesystem_unix_path.f90.html"},{"title":"fffc_string_to_upper.f90 – Fortran free function collection","text":"Contents Submodules fffc_string_to_upper Source Code fffc_string_to_upper.f90 Source Code submodule ( fffc_string ) fffc_string_to_upper contains module procedure to_upper integer :: i do i = 1 , len ( string ) select case ( string ( i : i )) case ( 'a' : 'z' ) upper ( i : i ) = char ( iachar ( string ( i : i )) - 32 ) case default upper ( i : i ) = string ( i : i ) end select end do end procedure to_upper end submodule fffc_string_to_upper","tags":"","loc":"sourcefile/fffc_string_to_upper.f90.html"},{"title":"fffc_terminal.F90 – Fortran free function collection","text":"Contents Modules fffc_terminal Source Code fffc_terminal.F90 Source Code !> 终端 module fffc_terminal use fffc_utils use , intrinsic :: iso_c_binding , only : ccr => c_carriage_return implicit none private public :: terminal , terminal_obj character ( * ), parameter :: colors ( * ) = [ achar ( 27 ) // '[31m' , & achar ( 27 ) // '[32m' , & achar ( 27 ) // '[33m' , & achar ( 27 ) // '[34m' , & achar ( 27 ) // '[00m' ] type terminal logical , private :: use_color = . false . contains procedure :: setup => set_terminal procedure :: progress_bar => terminal_progress_bar procedure :: info => terminal_info procedure :: warning => terminal_warning procedure :: error => terminal_error procedure :: success => terminal_success procedure :: blue , green , yellow , red end type terminal type ( terminal ) :: terminal_obj contains !> 设置终端输出 subroutine set_terminal ( self ) class ( terminal ), intent ( out ) :: self if (. not . is_env ( 'NO_COLOR' ) . and . & #ifdef NO_COLOR . false . & #else . true . & #endif ) then self % use_color = . true . else self % use_color = . false . end if end subroutine set_terminal !> 信息 subroutine terminal_info ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg write ( * , '(a)' ) self % blue ( msg ) end subroutine terminal_info !> 警告 subroutine terminal_warning ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg print * , self % yellow ( '[WARN]  ' // msg ) end subroutine terminal_warning !> 错误 subroutine terminal_error ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg print * , self % red ( '<ERROR> ' // msg ) stop 1 end subroutine terminal_error !> 成功 subroutine terminal_success ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg write ( * , '(a)' ) self % green ( msg ) end subroutine terminal_success !> 蓝色 pure function blue ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg character (:), allocatable :: blue if ( self % use_color ) then blue = colors ( 4 ) // msg // colors ( 5 ) else blue = msg end if end function blue !> 绿色 pure function green ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg character (:), allocatable :: green if ( self % use_color ) then green = colors ( 2 ) // msg // colors ( 5 ) else green = msg end if end function green !> 黄色 pure function yellow ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg character (:), allocatable :: yellow if ( self % use_color ) then yellow = colors ( 3 ) // msg // colors ( 5 ) else yellow = msg end if end function yellow !> 红色 pure function red ( self , msg ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg character (:), allocatable :: red if ( self % use_color ) then red = colors ( 1 ) // msg // colors ( 5 ) else red = msg end if end function red !> 进度条 subroutine terminal_progress_bar ( self , msg , p ) class ( terminal ), intent ( in ) :: self character ( * ), intent ( in ) :: msg real , intent ( in ) :: p character (:), allocatable :: bar integer :: length_ integer , parameter :: l = 35 real :: p_local length_ = len ( msg ) + l + 12 p_local = min ( 1.0 , max ( 0.0 , p )) allocate ( character ( length_ ) :: bar ) write ( bar , \"(2A,A2,A35,A2,F5.1,A2)\" ) ccr , msg , & \" [\" , repeat ( \"*\" , nint ( p_local * l )) // repeat ( \"-\" , l - nint ( p_local * l )), \"] \" , 100 * p , \" %\" write ( * , '(a)' , advance = 'no' ) bar end subroutine terminal_progress_bar end module fffc_terminal","tags":"","loc":"sourcefile/fffc_terminal.f90.html"},{"title":"fffc_kinds.F90 – Fortran free function collection","text":"Contents Modules fffc_kinds Source Code fffc_kinds.F90 Source Code module fffc_kinds #ifdef REAL64 integer , parameter :: fffc_real_kind = kind ( 0.0d0 ) #else integer , parameter :: fffc_real_kind = kind ( 0.0 ) #endif integer , parameter :: fffc_complex_kind = fffc_real_kind integer , parameter :: fffc_int_kind = kind ( 0 ) end module fffc_kinds","tags":"","loc":"sourcefile/fffc_kinds.f90.html"},{"title":"fffc_math_arange.f90 – Fortran free function collection","text":"Contents Submodules fffc_math_arange Source Code fffc_math_arange.f90 Source Code submodule ( fffc_math ) fffc_math_arange contains module procedure arange_real_kind real ( kind = fffc_real_kind ) :: step_ integer :: i if ( present ( step )) then step_ = step else step_ = 1.0_fffc_real_kind end if allocate ( ans , source = [( start + ( i - 1 ) * step_ , i = 1 , floor (( stop - start ) / step_ ) + 1 )]) end procedure arange_real_kind module procedure arange_int_kind integer ( kind = fffc_int_kind ) :: step_ integer :: i if ( present ( step )) then step_ = step else step_ = 1_fffc_int_kind end if allocate ( ans , source = [( i , i = start , stop , step_ )]) end procedure arange_int_kind end submodule fffc_math_arange","tags":"","loc":"sourcefile/fffc_math_arange.f90.html"},{"title":"rkf45_module.f90 – Fortran free function collection","text":"Contents Modules rkf45_module Source Code rkf45_module.f90 Source Code module rkf45_module use fffc_kinds , only : rk => fffc_real_kind private public :: rkf45 abstract interface !> `fcn` evaluates the derivative for the ODE. subroutine fcn ( t , y , yp ) import real ( kind = rk ), intent ( in ) :: t real ( kind = rk ), intent ( in ) :: y (:) real ( kind = rk ), intent ( out ) :: yp (:) end subroutine fcn end interface contains !> rkf45 is primarily designed to solve non-stiff and mildly stiff !> differential equations when derivative evaluations are inexpensive. !> rkf45 should generally not be used when the user is demanding !> high accuracy. !> 在计算量不大的计算中，rkf45主要用于求解非刚性和轻微刚性的常微分方程。 subroutine rkf45 ( f , neqn , y , t , tout , relerr , abserr , iflag , work , iwork ) !     fehlberg fourth-fifth order runge-kutta method !     written by h.a.watts and l.f.shampine !                   sandia laboratories !                  albuquerque,new mexico ! abstract !    subroutine  rkf45  integrates a system of neqn first order !    ordinary differential equations of the form !             dy(i)/dt = f(t,y(1),y(2),...,y(neqn)) !              where the y(i) are given at t . !    typically the subroutine is used to integrate from t to tout but it !    can be used as a one-step integrator to advance the solution a !    single step in the direction of tout.  on return the parameters in !    the call list are set for continuing the integration. the user has !    only to call rkf45 again (and perhaps define a new value for tout). !    actually, rkf45 is an interfacing routine which calls subroutine !    rkfs for the solution.  rkfs in turn calls subroutine  fehl which !    computes an approximate solution over one step. !    rkf45  uses the runge-kutta-fehlberg (4,5)  method described !    in the reference !    e.fehlberg , low-order classical runge-kutta formulas with stepsize !                 control , nasa tr r-315 !    the performance of rkf45 is illustrated in the reference !    l.f.shampine,h.a.watts,s.davenport, solving non-stiff ordinary !                 differential equations-the state of the art , !                 sandia laboratories report sand75-0182 , !                 to appear in siam review. !    the parameters represent- !      f -- subroutine f(t,y,yp) to evaluate derivatives yp(i)=dy(i)/dt !      neqn -- number of equations to be integrated !      y(*) -- solution vector at t !      t -- independent variable !      tout -- output point at which solution is desired !      relerr,abserr -- relative and absolute error tolerances for local !            error test. at each step the code requires that !                 abs(local error) .le. relerr*abs(y) + abserr !            for each component of the local error and solution vectors !      iflag -- indicator for status of integration !      work(*) -- array to hold information internal to rkf45 which is !            necessary for subsequent calls. must be dimensioned !            at least  3+6*neqn !      iwork(*) -- integer array used to hold information internal to !            rkf45 which is necessary for subsequent calls. must be !            dimensioned at least  5 !  first call to rkf45 !    the user must provide storage in his calling program for the arrays !    in the call list  -      y(neqn) , work(3+6*neqn) , iwork(5)  , !    declare f in an external statement, supply subroutine f(t,y,yp) and !    initialize the following parameters- !      neqn -- number of equations to be integrated.  (neqn .ge. 1) !      y(*) -- vector of initial conditions !      t -- starting point of integration , must be a variable !      tout -- output point at which solution is desired. !            t=tout is allowed on the first call only, in which case !            rkf45 returns with iflag=2 if continuation is possible. !      relerr,abserr -- relative and absolute local error tolerances !            which must be non-negative. relerr must be a variable while !            abserr may be a constant. the code should normally not be !            used with relative error control smaller than about 1.e-8 . !            to avoid limiting precision difficulties the code requires !            relerr to be larger than an internally computed relative !            error parameter which is machine dependent. in particular, !            pure absolute error is not permitted. if a smaller than !            allowable value of relerr is attempted, rkf45 increases !            relerr appropriately and returns control to the user before !            continuing the integration. !      iflag -- +1,-1  indicator to initialize the code for each new !            problem. normal input is +1. the user should set iflag=-1 !            only when one-step integrator control is essential. in this !            case, rkf45 attempts to advance the solution a single step !            in the direction of tout each time it is called. since this !            mode of operation results in extra computing overhead, it !            should be avoided unless needed. !  output from rkf45 !      y(*) -- solution at t !      t -- last point reached in integration. !      iflag = 2 -- integration reached tout. indicates successful retur !                   and is the normal mode for continuing integration. !            =-2 -- a single successful step in the direction of tout !                   has been taken. normal mode for continuing !                   integration one step at a time. !            = 3 -- integration was not completed because relative error !                   tolerance was too small. relerr has been increased !                   appropriately for continuing. !            = 4 -- integration was not completed because more than !                   3000 derivative evaluations were needed. this !                   is approximately 500 steps. !            = 5 -- integration was not completed because solution !                   vanished making a pure relative error test !                   impossible. must use non-zero abserr to continue. !                   using the one-step integration mode for one step !                   is a good way to proceed. !            = 6 -- integration was not completed because requested !                   accuracy could not be achieved using smallest !                   allowable stepsize. user must increase the error !                   tolerance before continued integration can be !                   attempted. !            = 7 -- it is likely that rkf45 is inefficient for solving !                   this problem. too much output is restricting the !                   natural stepsize choice. use the one-step integrator !                   mode. !            = 8 -- invalid input parameters !                   this indicator occurs if any of the following is !                   satisfied -   neqn .le. 0 !                                 t=tout  and  iflag .ne. +1 or -1 !                                 relerr or abserr .lt. 0. !                                 iflag .eq. 0  or  .lt. -2  or  .gt. 8 !      work(*),iwork(*) -- information which is usually of no interest !                   to the user but necessary for subsequent calls. !                   work(1),...,work(neqn) contain the first derivatives !                   of the solution vector y at t. work(neqn+1) contains !                   the stepsize h to be attempted on the next step. !                   iwork(1) contains the derivative evaluation counter. !  subsequent calls to rkf45 !    subroutine rkf45 returns with all information needed to continue !    the integration. if the integration reached tout, the user need onl !    define a new tout and call rkf45 again. in the one-step integrator !    mode (iflag=-2) the user must keep in mind that each step taken is !    in the direction of the current tout. upon reaching tout (indicated !    by changing iflag to 2),the user must then define a new tout and !    reset iflag to -2 to continue in the one-step integrator mode. !    if the integration was not completed but the user still wants to !    continue (iflag=3,4 cases), he just calls rkf45 again. with iflag=3 !    the relerr parameter has been adjusted appropriately for continuing !    the integration. in the case of iflag=4 the function counter will !    be reset to 0 and another 3000 function evaluations are allowed. !    however,in the case iflag=5, the user must first alter the error !    criterion to use a positive value of abserr before integration can !    proceed. if he does not,execution is terminated. !    also,in the case iflag=6, it is necessary for the user to reset !    iflag to 2 (or -2 when the one-step integration mode is being used) !    as well as increasing either abserr,relerr or both before the !    integration can be continued. if this is not done, execution will !    be terminated. the occurrence of iflag=6 indicates a trouble spot !    (solution is changing rapidly,singularity may be present) and it !    often is inadvisable to continue. !    if iflag=7 is encountered, the user should use the one-step !    integration mode with the stepsize determined by the code or !    consider switching to the adams codes de/step,intrp. if the user !    insists upon continuing the integration with rkf45, he must reset !    iflag to 2 before calling rkf45 again. otherwise,execution will be !    terminated. !    if iflag=8 is obtained, integration can not be continued unless !    the invalid input parameters are corrected. !    it should be noted that the arrays work,iwork contain information !    required for subsequent integration. accordingly, work and iwork !    should not be altered. integer , intent ( in ) :: neqn real ( kind = rk ), intent ( inout ) :: y ( neqn ) real ( kind = rk ), intent ( inout ) :: t real ( kind = rk ), intent ( in ) :: tout integer , intent ( inout ) :: iflag , iwork ( 5 ) real ( kind = rk ), intent ( inout ) :: relerr , work ( * ) real ( kind = rk ), intent ( in ) :: abserr procedure ( fcn ) :: f integer :: k1 , k2 , k3 , k4 , k5 , k6 , k1m !     compute indices for the splitting of the work array k1m = neqn + 1 k1 = k1m + 1 k2 = k1 + neqn k3 = k2 + neqn k4 = k3 + neqn k5 = k4 + neqn k6 = k5 + neqn !     this interfacing routine merely relieves the user of a long !     calling list via the splitting apart of two working storage !     arrays. if this is not compatible with the users compiler, !     he must use rkfs directly. call rkfs ( f , neqn , y , t , tout , relerr , abserr , iflag , & work ( 1 ), work ( k1m ), work ( k1 ), work ( k2 ), work ( k3 ), work ( k4 ), work ( k5 ), work ( k6 ), work ( k6 + 1 ), & iwork ( 1 ), iwork ( 2 ), iwork ( 3 ), iwork ( 4 ), iwork ( 5 )) return end subroutine rkf45 !> rkfs integrates a system of first order ordinary differential !> equations as described in the comments for rkf45 . subroutine rkfs ( f , neqn , y , t , tout , relerr , abserr , iflag , & yp , h , f1 , f2 , f3 , f4 , f5 , savre , savae , & nfe , kop , init , jflag , kflag ) !     rkfs integrates a system of first order ordinary differential !     equations as described in the comments for rkf45 . !     the arrays yp,f1,f2,f3,f4,and f5 (of dimension at least neqn) and !     the variables h,savre,savae,nfe,kop,init,jflag,and kflag are used !     internally by the code and appear in the call list to eliminate !     local retention of variables between calls. accordingly, they !     should not be altered. items of possible interest are !         yp - derivative of solution vector at t !         h  - an appropriate stepsize to be used for the next step !         nfe- counter on the number of derivative function evaluations logical :: hfaild , output integer , intent ( in ) :: neqn real ( kind = rk ), intent ( inout ) :: y ( neqn ) real ( kind = rk ), intent ( inout ) :: t real ( kind = rk ), intent ( in ) :: tout integer , intent ( inout ) :: iflag real ( kind = rk ), intent ( inout ) :: relerr integer :: nfe , kop , init , jflag , kflag real ( kind = rk ) :: abserr , h , yp ( neqn ), f1 ( neqn ), f2 ( neqn ), f3 ( neqn ), f4 ( neqn ), f5 ( neqn ), savre , savae procedure ( fcn ) :: f real ( kind = rk ) a , ae , dt , ee , eeoet , esttol , et , hmin , remin , rer , s , scale , tol , toln , twoeps , u26 , ypk integer :: k , maxnfe , mflag !  remin is the minimum acceptable value of relerr.  attempts !  to obtain higher accuracy with this subroutine are usually !  very expensive and often unsuccessful. data remin / 1.e-12_rk / !     the expense is controlled by restricting the number !     of function evaluations to be approximately maxnfe. !     as set, this corresponds to about 500 steps. data maxnfe / 3000 / !   here two constants emboding the machine epsilon is present !   twoesp is set to twice the machine epsilon while u26 is set !   to 26 times the machine epsilon data twoeps , u26 / 4.4e-16 , 5.72e-15 / !> Check input parameters if ( neqn < 1 . or . relerr < 0.0_rk . or . abserr < 0.0_rk ) goto 10 mflag = abs ( iflag ) if (( mflag >= 1 ) . and . ( mflag <= 8 )) goto 20 !     invalid input 10 iflag = 8 return !     is this the first call 20 if ( mflag == 1 ) goto 50 !     check continuation possibilities if (( abs ( t - tout ) <= twoeps ) . and . ( kflag /= 3 )) goto 10 if ( mflag /= 2 ) goto 25 !     iflag = +2 or -2 if ( kflag == 3 ) goto 45 if ( init == 0 ) goto 45 if ( kflag == 4 ) goto 40 if (( kflag == 5 ) . and . ( abserr == 0.0_rk )) goto 30 if (( kflag == 6 ) . and . ( relerr <= savre ) . and . ( abserr <= savae )) goto 30 goto 50 !     iflag = 3,4,5,6,7 or 8 25 if ( iflag == 3 ) goto 45 if ( iflag == 4 ) goto 40 if (( iflag == 5 ) . and . ( abserr > 0.0_rk )) goto 45 !     integration cannot be continued since user did not respond to !     the instructions pertaining to iflag=5,6,7 or 8 30 stop !     reset function evaluation counter 40 nfe = 0 if ( mflag == 2 ) goto 50 !     reset flag value from previous call 45 iflag = jflag if ( kflag == 3 ) mflag = abs ( iflag ) !     save input iflag and set continuation flag value for subsequent !     input checking 50 jflag = iflag kflag = 0 !     save relerr and abserr for checking input on subsequent calls savre = relerr savae = abserr !     restrict relative error tolerance to be at least as large as !     2*eps+remin to avoid limiting precision difficulties arising !     from impossible accuracy requests rer = twoeps + remin if ( relerr >= rer ) goto 55 !     relative error tolerance too small relerr = rer iflag = 3 kflag = 3 return 55 dt = tout - t if ( mflag == 1 ) goto 60 if ( init == 0 ) goto 65 goto 80 !     initialization -- !                       set initialization completion indicator,init !                       set indicator for too many output points,kop !                       evaluate initial derivatives !                       set counter for function evaluations,nfe !                       evaluate initial derivatives !                       set counter for function evaluations,nfe !                       estimate starting stepsize 60 init = 0 kop = 0 a = t call f ( a , y , yp ) nfe = 1 if ( t /= tout ) goto 65 iflag = 2 return 65 init = 1 h = abs ( dt ) toln = 0. do k = 1 , neqn tol = relerr * abs ( y ( k )) + abserr if ( tol <= 0. ) goto 70 toln = tol ypk = abs ( yp ( k )) if ( ypk * h ** 5 > tol ) h = ( tol / ypk ) ** 0.2_rk 70 end do if ( toln <= 0.0_rk ) h = 0.0_rk h = max ( h , u26 * max ( abs ( t ), abs ( dt ))) jflag = sign ( 2 , iflag ) !     set stepsize for integration in the direction from t to tout 80 h = sign ( h , dt ) !     test to see if rkf45 is being severely impacted by too many !     output points if ( abs ( h ) >= 2.0_rk * abs ( dt )) kop = kop + 1 if ( kop /= 100 ) goto 85 !     unnecessary frequency of output kop = 0 iflag = 7 return 85 if ( abs ( dt ) > u26 * abs ( t )) goto 95 !     if too close to output point,extrapolate and return do k = 1 , neqn y ( k ) = y ( k ) + dt * yp ( k ) end do a = tout call f ( a , y , yp ) nfe = nfe + 1 goto 300 !     initialize output point indicator 95 output = . false . !     to avoid premature underflow in the error tolerance function, !     scale the error tolerances scale = 2.0_rk / relerr ae = scale * abserr !     step by step integration 100 hfaild = . false . !     set smallest allowable stepsize hmin = u26 * abs ( t ) !     adjust stepsize if necessary to hit the output point. !     look ahead two steps to avoid drastic changes in the stepsize and !     thus lessen the impact of output points on the code. dt = tout - t if ( abs ( dt ) >= 2.0_rk * abs ( h )) goto 200 if ( abs ( dt ) > abs ( h )) goto 150 !     the next successful step will complete the integration to the !     output point output = . true . h = dt goto 200 150 h = 0.5_rk * dt !     core integrator for taking a single step !     the tolerances have been scaled to avoid premature underflow in !     computing the error tolerance function et. !     to avoid problems with zero crossings,relative error is measured !     using the average of the magnitudes of the solution at the !     beginning and end of a step. !     the error estimate formula has been grouped to control loss of !     significance. !     to distinguish the various arguments, h is not permitted !     to become smaller than 26 units of roundoff in t. !     practical limits on the change in the stepsize are enforced to !     smooth the stepsize selection process and to avoid excessive !     chattering on problems having discontinuities. !     to prevent unnecessary failures, the code uses 9/10 the stepsize !     it estimates will succeed. !     after a step failure, the stepsize is not allowed to increase for !     the next attempted step. this makes the code more efficient on !     problems having discontinuities and more effective in general !     since local extrapolation is being used and extra caution seems !     warranted. !     test number of derivative function evaluations. !     if okay,try to advance the integration from t to t+h 200 if ( nfe <= maxnfe ) goto 220 !     too much work iflag = 4 kflag = 4 return !     advance an approximate solution over one step of length h 220 call fehl ( f , neqn , y , t , h , yp , f1 , f2 , f3 , f4 , f5 , f1 ) nfe = nfe + 5 !     compute and test allowable tolerances versus local error estimates !     and remove scaling of tolerances. note that relative error is !     measured with respect to the average of the magnitudes of the !     solution at the beginning and end of the step. eeoet = 0.0_rk do k = 1 , neqn et = abs ( y ( k )) + abs ( f1 ( k )) + ae if ( et > 0.0_rk ) goto 240 !       inappropriate error tolerance iflag = 5 return 240 ee = abs (( - 209 0.0_rk * yp ( k ) + & ( 2197 0.0_rk * f3 ( k ) - 1504 8.0_rk * f4 ( k ))) + & ( 2252 8.0_rk * f2 ( k ) - 2736 0.0_rk * f5 ( k ))) eeoet = max ( eeoet , ee / et ) end do esttol = abs ( h ) * eeoet * scale / 75240 0.0_rk if ( esttol <= 1.0_rk ) goto 260 !     unsuccessful step !                       reduce the stepsize , try again !                       the decrease is limited to a factor of 1/10 hfaild = . true . output = . false . s = 0.1_rk if ( esttol < 5904 9.0_rk ) s = 0.9_rk / esttol ** 0.2_rk h = s * h if ( abs ( h ) > hmin ) goto 200 !     requested error unattainable at smallest allowable stepsize iflag = 6 kflag = 6 return !     successful step !                        store solution at t+h !                        and evaluate derivatives there 260 t = t + h do k = 1 , neqn y ( k ) = f1 ( k ) end do a = t call f ( a , y , yp ) nfe = nfe + 1 !                       choose next stepsize !                       the increase is limited to a factor of 5 !                       if step failure has just occurred, next !                          stepsize is not allowed to increase s = 5.0_rk if ( esttol > 1.889568e-4_rk ) s = 0.9_rk / esttol ** 0.2_rk if ( hfaild ) s = min ( s , 1.0_rk ) h = sign ( max ( s * abs ( h ), hmin ), h ) !     end of core integrator !     should we take another step if ( output ) goto 300 if ( iflag > 0 ) goto 100 !     integration successfully completed !     one-step mode iflag = - 2 return !     interval mode 300 t = tout iflag = 2 return end subroutine rkfs !> fehl integrates a system of neqn first order !> ordinary differential equations of the form !>          dy(i)/dt=f(t,y(1),---,y(neqn)) !> where the initial values y(i) and the initial derivatives !> yp(i) are specified at the starting point t. subroutine fehl ( f , neqn , y , t , h , yp , f1 , f2 , f3 , f4 , f5 , s ) !    fehl advances the solution over the fixed step h and returns !    the fifth order (sixth order accurate locally) solution !    approximation at t+h in array s(i). !    f1,---,f5 are arrays of dimension neqn which are needed !    for internal storage. !    the formulas have been grouped to control loss of significance. !    fehl should be called with an h not smaller than 13 units of !    roundoff in t so that the various independent arguments can be !    distinguished. procedure ( fcn ) :: f integer , intent ( in ) :: neqn real ( kind = rk ) y ( neqn ), t , h , yp ( neqn ), f1 ( neqn ), f2 ( neqn ), f3 ( neqn ), f4 ( neqn ), f5 ( neqn ), s ( neqn ) real ( kind = rk ) ch integer k ch = h / 4.0_rk do k = 1 , neqn f5 ( k ) = y ( k ) + ch * yp ( k ) end do call f ( t + ch , f5 , f1 ) ch = 3.0_rk * h / 3 2.0_rk do k = 1 , neqn f5 ( k ) = y ( k ) + ch * ( yp ( k ) + 3.0_rk * f1 ( k )) end do call f ( t + 3.0_rk * h / 8.0_rk , f5 , f2 ) ch = h / 219 7.0_rk do k = 1 , neqn f5 ( k ) = y ( k ) + ch * ( 193 2.0_rk * yp ( k ) + ( 729 6.0_rk * f2 ( k ) - 720 0.0_rk * f1 ( k ))) end do call f ( t + 1 2.0_rk * h / 1 3.0_rk , f5 , f3 ) ch = h / 410 4.0_rk do k = 1 , neqn f5 ( k ) = y ( k ) + ch * (( 834 1.0_rk * yp ( k ) - 84 5.0_rk * f3 ( k )) + & ( 2944 0.0_rk * f2 ( k ) - 3283 2.0_rk * f1 ( k ))) end do call f ( t + h , f5 , f4 ) ch = h / 2052 0.0_rk do k = 1 , neqn f1 ( k ) = y ( k ) + ch * (( - 608 0.0_rk * yp ( k ) + & ( 929 5.0_rk * f3 ( k ) - 564 3.0_rk * f4 ( k ))) & + ( 4104 0.0_rk * f1 ( k ) - 2835 2.0_rk * f2 ( k ))) end do call f ( t + h / 2.0_rk , f1 , f5 ) !> compute approximate solution at t+h ch = h / 761805 0.0_rk do k = 1 , neqn s ( k ) = y ( k ) + ch * (( 90288 0.0_rk * yp ( k ) + ( 385573 5.0_rk * f3 ( k ) - & 137124 9.0_rk * f4 ( k ))) & + ( 395366 4.0_rk * f2 ( k ) + 27702 0.0_rk * f5 ( k ))) end do return end subroutine fehl end module rkf45_module","tags":"","loc":"sourcefile/rkf45_module.f90.html"},{"title":"fffc_linalg_det.F90 – Fortran free function collection","text":"Contents Submodules fffc_linalg_det Source Code fffc_linalg_det.F90 Source Code #ifdef REAL64 #define sgetrf dgetrf #endif submodule ( fffc_linalg ) fffc_linalg_det contains module procedure det integer :: ipiv ( size ( a , 1 )), info , i , count call sgetrf ( size ( a , 1 ), size ( a , 2 ), a , size ( a , 1 ), ipiv , info ) ans = 1.0_fffc_real_kind do i = 1 , size ( a , 1 ) ans = ans * a ( i , i ) end do count = 0 do i = 1 , size ( a , 1 ) if ( ipiv ( i ) /= i ) then count = count + 1 end if end do if ( mod ( count , 2 ) == 1 ) ans = - ans end procedure det end submodule fffc_linalg_det","tags":"","loc":"sourcefile/fffc_linalg_det.f90.html"},{"title":"fffc_string_to_string.f90 – Fortran free function collection","text":"Contents Submodules fffc_string_to_string Source Code fffc_string_to_string.f90 Source Code submodule ( fffc_string ) fffc_string_to_string contains module procedure to_string_real_kind character ( len = 128 ) :: s write ( s , \"(\" // fmt // \")\" ) real string = trim ( s ) end procedure to_string_real_kind module procedure to_string_int_kind character ( len = 128 ) :: s write ( s , \"(\" // fmt // \")\" ) int string = trim ( s ) end procedure to_string_int_kind module procedure to_string_logical_kind character ( len = 128 ) :: s write ( s , \"(\" // fmt // \")\" ) logical string = trim ( s ) end procedure to_string_logical_kind end submodule fffc_string_to_string","tags":"","loc":"sourcefile/fffc_string_to_string.f90.html"}]}